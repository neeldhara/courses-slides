<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reductions</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Overlock:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        /* Heliotrope font */
        @font-face {
            font-family: 'Heliotrope';
            src: url('../../assets/fonts/heliotrope_3_regular.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Heliotrope';
            src: url('../../assets/fonts/heliotrope_3_bold.woff2') format('woff2');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Heliotrope';
            src: url('../../assets/fonts/heliotrope_3_italic.woff2') format('woff2');
            font-weight: normal;
            font-style: italic;
            font-display: swap;
        }
        @font-face {
            font-family: 'Heliotrope';
            src: url('../../assets/fonts/heliotrope_3_bold_italic.woff2') format('woff2');
            font-weight: bold;
            font-style: italic;
            font-display: swap;
        }
    </style>

    <!-- RevealJS CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/white.min.css">

    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">

    <style>
        /* ============================================
           CLEAN MINIMALIST STYLES - gwern.net inspired
           ============================================ */

        :root, .reveal {
            /* Base palette */
            --bg-main: #f5f5f5;
            --bg-slide: #ffffff;
            --text: #222222;
            --text-primary: #222222;
            --text-secondary: #666666;
            --text-light: #666666;
            --border: #cccccc;
            --border-dark: #888888;
            --border-light: #dddddd;
            --border-medium: #aaaaaa;
            --error: #c44;
            --r-main-color: #222222;
            --r-heading-color: #222222;
            --r-link-color: #222222;
            --r-selection-color: #222222;

            /* 7 distinct pastel accent colors */
            --pastel-blue: #a8d4f0;
            --pastel-green: #b8e6c1;
            --pastel-coral: #f5c4c0;
            --pastel-lavender: #d4c4e8;
            --pastel-gold: #f5e6a3;
            --pastel-mint: #a8e6d5;
            --pastel-peach: #f5d4b8;
        }

        /* Base reveal overrides */
        .reveal-viewport {
            background: var(--bg-main);
        }

        .reveal {
            font-family: 'Heliotrope', Georgia, serif;
            font-size: 20px;
            color: var(--text);
        }

        .reveal .slides {
            text-align: left;
        }

        /* Slide container with double border - consistent sizing */
        .reveal .slides > section {
            background: var(--bg-slide);
            border: 3px double var(--border);
            padding: 55px 35px 30px 35px;
            box-sizing: border-box;
            width: 100% !important;
            height: 100% !important;
        }

        /* Nested sections (vertical slides) */
        .reveal .slides section > section {
            border: none;
            padding: 40px 0 0 0 !important;
            background: transparent;
            width: 100% !important;
            height: 100% !important;
        }

        /* Ensure all text is dark by default */
        .reveal .slides section {
            color: var(--text) !important;
        }
        .reveal .slides section p,
        .reveal .slides section span,
        .reveal .slides section li,
        .reveal .slides section strong,
        .reveal .slides section em,
        .reveal .slides section div {
            color: var(--text);
        }

        /* Ensure fragments are visible */
        .reveal .slides .fragment,
        .reveal .slides .fragment * {
            color: var(--text) !important;
        }

        /* Exceptions for elements with dark backgrounds */
        .reveal .slides .btn-primary,
        .reveal .slides .nav-btn:not(.back),
        .reveal .slides table th {
            color: white !important;
        }

        /* Typography */
        .reveal h1, .reveal h2, .reveal h3 {
            font-family: 'EB Garamond', Georgia, serif;
            font-weight: 700;
            color: var(--text);
            text-transform: none;
            letter-spacing: -0.01em;
        }

        .reveal h1 {
            font-size: 1.7em;
            margin-bottom: 0.3em;
        }

        .reveal h2 {
            font-size: 1.25em;
            margin-bottom: 0.25em;
            padding-bottom: 0.15em;
            border-bottom: 1px solid var(--border-dark);
            display: inline-block;
        }

        .reveal h3 {
            font-size: 0.95em;
            margin-bottom: 0.2em;
            font-style: italic;
            color: var(--text-light);
        }

        .reveal p {
            color: var(--text);
            line-height: 1.5;
            margin-bottom: 0.5em;
        }

        .reveal ul, .reveal ol {
            color: var(--text);
            margin-left: 1em;
        }

        .reveal li {
            color: var(--text);
            margin-bottom: 0.3em;
            line-height: 1.45;
        }

        .reveal strong {
            color: var(--text);
            font-weight: 700;
        }

        .reveal em {
            color: var(--text-light);
        }

        /* Simple framed boxes */
        .definition-box, .theorem-box, .algorithm-box, .success-box {
            background: var(--bg-slide);
            border: 1px solid var(--border-dark);
            padding: 10px 14px;
            margin: 10px 0;
            max-width: 88%;
            box-sizing: border-box;
        }

        .definition-box {
            border-left: 3px solid var(--pastel-blue);
        }

        .theorem-box {
            border-left: 3px solid var(--pastel-green);
        }

        .algorithm-box {
            border-left: 3px solid var(--pastel-lavender);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em;
            line-height: 1.6;
            background: #fafafa;
        }

        .success-box {
            border-left: 3px solid var(--pastel-mint);
        }

        .goal-box {
            border-left: 3px solid #9b8bb8;
        }

        .algorithm-box .keyword {
            font-weight: 700;
            color: var(--text);
        }

        /* Demo containers */
        .demo-container {
            background: #fafafa;
            border: 1px solid var(--border);
            padding: 10px;
            margin: 10px 0;
            max-width: 95%;
            box-sizing: border-box;
        }

        .demo-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
            gap: 8px;
        }

        .demo-title {
            font-family: 'Overlock', sans-serif;
            font-weight: 700;
            color: var(--text);
            font-size: 0.9em;
        }

        .demo-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .demo-controls label {
            font-size: 0.75em;
            color: var(--text-light);
            font-weight: 600;
        }

        .demo-controls input {
            background: white;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 4px 6px;
            font-size: 0.8em;
            width: 50px;
        }

        .demo-controls input:focus {
            outline: none;
            border-color: var(--border-dark);
        }

        .demo-canvas {
            background: white;
            border: 1px solid var(--border);
            margin: 8px 0;
            min-height: 280px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .demo-output {
            background: white;
            border: 1px solid var(--border);
            padding: 8px 12px;
            margin-top: 8px;
            font-size: 0.85em;
            color: var(--text);
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Buttons */
        .btn {
            background: white;
            border: 1px solid var(--border-dark);
            padding: 5px 12px;
            cursor: pointer;
            font-size: 0.75em;
            font-weight: 600;
            font-family: 'Heliotrope', sans-serif;
            color: var(--text);
            transition: background 0.2s;
        }

        .btn:hover {
            background: #f0f0f0;
        }

        .btn-primary {
            background: var(--text);
            color: white;
            border-color: var(--text);
        }

        .btn-primary:hover {
            background: #444444;
        }

        .btn-success {
            background: var(--pastel-green);
            border-color: #8bc99b;
            color: var(--text);
        }

        .btn-warning {
            background: var(--pastel-gold);
            border-color: #d4c47a;
            color: var(--text);
        }

        .btn-secondary {
            background: #eeeeee;
            border-color: var(--border);
            color: var(--text);
        }

        /* Approach cards */
        .approach-grid {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin: 10px 0;
            max-width: 88%;
        }

        .approach-card {
            background: white;
            border: 1px solid var(--border);
            padding: 8px 10px;
            text-decoration: none;
            box-sizing: border-box;
        }

        .approach-card:hover {
            background: #f8f8f8;
            border-color: var(--border-dark);
        }

        .approach-card h3 {
            font-size: 0.9em;
            margin-bottom: 4px;
            color: var(--text);
            font-style: normal;
        }

        .approach-card p {
            font-size: 0.8em;
            color: var(--text-light);
            margin: 0;
        }

        .approach-card.correct {
            border: 2px solid var(--pastel-green);
            background: #f8fff8;
        }

        /* Navigation buttons */
        .nav-btn {
            display: inline-block;
            padding: 5px 12px;
            background: var(--text);
            color: white;
            text-decoration: none;
            font-size: 0.75em;
            font-weight: 600;
        }

        .nav-btn:hover {
            background: #444444;
        }

        .nav-btn.back {
            background: white;
            color: var(--text);
            border: 1px solid var(--border-dark);
        }

        .bottom-nav {
            position: absolute;
            bottom: 60px;
            left: 0;
            right: 0;
            text-align: center;
        }

        /* Title slide */
        .title-slide {
            text-align: center;
        }

        .title-slide h1 {
            font-size: 2em;
        }

        .subtitle {
            color: var(--text-light);
            font-size: 1.1em;
            margin-bottom: 1.5em;
        }

        /* Section title slide */
        .section-title {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .section-title h1 {
            font-size: 1.8em;
            text-align: center;
        }

        /* Tables */
        .reveal table {
            color: var(--text);
        }

        .reveal table th {
            background: var(--text);
            color: white;
            padding: 8px;
        }

        .reveal table td {
            color: var(--text);
            padding: 6px 8px;
            border: 1px solid var(--border);
        }

        /* Feedback messages */
        .feedback {
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 0.85em;
            border: 1px solid var(--border);
        }

        .feedback-success {
            background: #f0fff0;
            border-color: var(--pastel-green);
            color: var(--text);
        }

        .feedback-error {
            background: #fff5f5;
            border-color: var(--pastel-coral);
            color: var(--text);
        }

        .feedback-info {
            background: #f5faff;
            border-color: var(--pastel-blue);
            color: var(--text);
        }

        /* Small text helpers */
        .small { font-size: 0.85em; }
        .tiny { font-size: 0.75em; }

        /* Highlight for key terms */
        .highlight {
            background: var(--pastel-gold);
            padding: 1px 4px;
        }

        /* Slide number */
        .reveal .slide-number {
            background: transparent;
            color: var(--text-light);
            font-size: 11px;
        }

        /* Progress bar */
        .reveal .progress {
            height: 3px;
            background: var(--border);
        }

        .reveal .progress span {
            background: var(--text);
        }

        /* KaTeX math */
        .reveal .katex {
            color: var(--text);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- ===== TITLE ===== -->
            <section class="title-slide">
                <h1>Reductions</h1>
                <p class="subtitle">Computational Complexity and Problem Transformations</p>

                <div style="margin-top: 350px; text-align:left; font-size: 0.75em;">
                    <p>Slides made in collaboration with Claude. All the cool bits are thanks to Claude, and blame <a href="https://www.neeldhara.com" style="color: seagreen;">me</a> for oversights :)</p>
                </div>
            </section>

            <!-- ===== SECTION 1: Reductions: an Overview ===== -->
            <section>
                <section class="section-title">
                    <h1>Reductions: an Overview</h1>
                </section>

                <section>
                    <h2></h2>
                </section>
            </section>

            <!-- ===== SECTION 2: Flows ===== -->
            <section>
                <section class="section-title">
                    <h1>Flows</h1>
                </section>

                <!-- Interactive Flow Network -->
                <section>
                    <h2>A Flow Network</h2>
                    <div class="demo-container" style="max-width: 92%;">
                        <div class="demo-header">
                            <span class="demo-title">Interactive Flow Network</span>
                            <div class="demo-controls">
                                <button class="btn btn-secondary" onclick="resetFlows()">Reset Flows</button>
                            </div>
                        </div>
                        <div id="flow-network-container" style="display: flex; justify-content: center; align-items: center; min-height: 300px;">
                            <svg id="flow-svg" width="620" height="290" viewBox="0 0 620 290" style="font-family: 'Heliotrope', Georgia, serif;">
                                <!-- Definitions for arrowheads -->
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#555"/>
                                    </marker>
                                </defs>

                                <!-- Source indicator arrow -->
                                <line x1="15" y1="145" x2="40" y2="145" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <!-- Sink indicator arrow -->
                                <line x1="515" y1="145" x2="545" y2="145" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <!-- Edge: s -> v1 (capacity 20) -->
                                <line id="edge-s-v1" x1="70" y1="130" x2="160" y2="65" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(100, 82)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-s-v1">0</tspan>/<tspan>20</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('s-v1', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('s-v1', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: s -> v3 (capacity 10) -->
                                <line id="edge-s-v3" x1="70" y1="160" x2="160" y2="225" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(100, 208)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-s-v3">0</tspan>/<tspan>10</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('s-v3', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('s-v3', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v1 -> v2 (capacity 5) -->
                                <line id="edge-v1-v2" x1="196" y1="50" x2="358" y2="50" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(277, 22)">
                                    <text x="0" y="-4" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v1-v2">0</tspan>/<tspan>5</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v2', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v2', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v1 -> v3 (capacity 10) -->
                                <line id="edge-v1-v3" x1="180" y1="70" x2="180" y2="215" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(205, 140)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v1-v3">0</tspan>/<tspan>10</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v3', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v3', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v1 -> v4 (capacity 15) - diagonal -->
                                <line id="edge-v1-v4" x1="192" y1="68" x2="362" y2="218" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(300, 125)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v1-v4">0</tspan>/<tspan>15</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v4', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v1-v4', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v3 -> v4 (capacity 10) -->
                                <line id="edge-v3-v4" x1="196" y1="240" x2="358" y2="240" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(277, 258)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v3-v4">0</tspan>/<tspan>10</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v3-v4', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v3-v4', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v4 -> v2 (capacity 10) -->
                                <line id="edge-v4-v2" x1="377" y1="215" x2="377" y2="70" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(407, 140)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v4-v2">0</tspan>/<tspan>10</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v4-v2', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v4-v2', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v2 -> t (capacity 15) -->
                                <line id="edge-v2-t" x1="393" y1="62" x2="480" y2="130" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(452, 82)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v2-t">0</tspan>/<tspan>15</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v2-t', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v2-t', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Edge: v4 -> t (capacity 20) -->
                                <line id="edge-v4-t" x1="393" y1="228" x2="480" y2="160" stroke="#555" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <g class="edge-control" transform="translate(452, 208)">
                                    <text x="0" y="-6" text-anchor="middle" font-size="13" fill="#222" font-weight="600" font-family="Heliotrope, Georgia, serif"><tspan id="flow-v4-t">0</tspan>/<tspan>20</tspan></text>
                                    <g class="flow-buttons">
                                        <rect x="-26" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v4-t', -1)"/>
                                        <text x="-16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">−</text>
                                        <rect x="6" y="2" width="20" height="16" rx="3" fill="#eee" stroke="#aaa" style="cursor:pointer" onclick="adjustFlow('v4-t', 1)"/>
                                        <text x="16" y="14" text-anchor="middle" font-size="13" fill="#555" style="pointer-events:none" font-family="Heliotrope, Georgia, serif">+</text>
                                    </g>
                                </g>

                                <!-- Nodes -->
                                <!-- Source s -->
                                <circle id="node-s" cx="55" cy="145" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="55" y="175" text-anchor="middle" font-size="14" font-weight="600" font-style="italic" fill="#222" font-family="Heliotrope, Georgia, serif">s</text>
                                <text id="netflow-s" x="55" y="150" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>

                                <!-- v1 -->
                                <circle id="node-v1" cx="180" cy="50" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="153" y="40" text-anchor="middle" font-size="12" fill="#222" font-family="Heliotrope, Georgia, serif">v₁</text>
                                <text id="netflow-v1" x="180" y="55" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>

                                <!-- v2 -->
                                <circle id="node-v2" cx="377" cy="50" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="404" y="40" text-anchor="middle" font-size="12" fill="#222" font-family="Heliotrope, Georgia, serif">v₂</text>
                                <text id="netflow-v2" x="377" y="55" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>

                                <!-- v3 -->
                                <circle id="node-v3" cx="180" cy="240" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="153" y="255" text-anchor="middle" font-size="12" fill="#222" font-family="Heliotrope, Georgia, serif">v₃</text>
                                <text id="netflow-v3" x="180" y="245" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>

                                <!-- v4 -->
                                <circle id="node-v4" cx="377" cy="240" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="404" y="255" text-anchor="middle" font-size="12" fill="#222" font-family="Heliotrope, Georgia, serif">v₄</text>
                                <text id="netflow-v4" x="377" y="245" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>

                                <!-- Sink t -->
                                <circle id="node-t" cx="495" cy="145" r="16" fill="white" stroke="#222" stroke-width="2"/>
                                <text x="495" y="175" text-anchor="middle" font-size="14" font-weight="600" font-style="italic" fill="#222" font-family="Heliotrope, Georgia, serif">t</text>
                                <text id="netflow-t" x="495" y="150" text-anchor="middle" font-size="12" font-weight="600" fill="#222" font-family="Heliotrope, Georgia, serif">0</text>
                            </svg>
                        </div>
                        <div class="demo-output" id="flow-commentary">
                            Here's a flow network. What is the maximum flow that you can drive through it?
                        </div>
                    </div>
                </section>

                <!-- Definition Slide -->
                <section>
                    <h2>Flow: Formal Definition</h2>
                    <div class="definition-box">
                        <p><strong>Flow Network:</strong> A directed graph \(G = (V, E)\) with:</p>
                        <ul>
                            <li class="fragment">A <strong>source</strong> vertex \(s\) and a <strong>sink</strong> vertex \(t\)</li>
                            <li class="fragment">A <strong>capacity function</strong> \(c: E \to \mathbb{R}_{\geq 0}\)</li>
                        </ul>
                    </div>

                    <div class="definition-box fragment" style="margin-top: 15px;">
                        <p><strong>(s,t)-Flow:</strong> A function \(f: E \to \mathbb{R}\) satisfying the <em>conservation constraint</em> at every vertex \(v\) except \(s\) and \(t\):</p>
                        <p style="text-align: center; margin: 10px 0; font-size: 1.1em;">
                            \(\displaystyle\sum_{u} f(u \to v) = \sum_{w} f(v \to w)\)
                        </p>
                        <p class="small" style="color: var(--text-light);"><em>In words: flow into \(v\) equals flow out of \(v\)</em></p>
                    </div>

                    <div class="fragment" style="margin-top: 15px;">
                        <p><strong>Value of a flow:</strong> \(\displaystyle|f| := \sum_{w} f(s \to w) - \sum_{u} f(u \to s)\)</p>
                        <p class="small" style="color: var(--text-light);"><em>The net flow leaving the source</em></p>
                    </div>
                </section>

                <!-- Feasibility Slide -->
                <section>
                    <h2>Feasible Flows</h2>
                    <div class="definition-box">
                        <p>A flow \(f\) is <strong>feasible</strong> with respect to capacity \(c\) if:</p>
                        <p style="text-align: center; margin: 10px 0; font-size: 1.1em;">
                            \(0 \leq f(e) \leq c(e)\) for every edge \(e\)
                        </p>
                    </div>

                    <div class="fragment" style="margin-top: 20px;">
                        <p><strong>Terminology:</strong></p>
                        <ul>
                            <li class="fragment">Flow <strong>saturates</strong> edge \(e\) if \(f(e) = c(e)\)</li>
                            <li class="fragment">Flow <strong>avoids</strong> edge \(e\) if \(f(e) = 0\)</li>
                        </ul>
                    </div>

                    <div class="definition-box goal-box fragment" style="margin-top: 20px;">
                        <p><strong>Maximum Flow Problem:</strong> Given a flow network \((G, s, t, c)\), compute a feasible \((s,t)\)-flow with maximum value.</p>
                    </div>
                </section>

                <!-- Cuts Definition Slide -->
                <section>
                    <h2>Cuts</h2>
                    <div class="definition-box">
                        <p><strong>(s,t)-cut:</strong> A partition of vertices into disjoint subsets \(S\) and \(T\) where:</p>
                        <ul>
                            <li class="fragment">\(S \cup T = V\) and \(S \cap T = \emptyset\)</li>
                            <li class="fragment">\(s \in S\) and \(t \in T\)</li>
                        </ul>
                    </div>

                    <div class="definition-box fragment" style="margin-top: 20px;">
                        <p><strong>Capacity of a cut:</strong></p>
                        <p style="text-align: center; margin: 10px 0; font-size: 1.1em;">
                            \(\displaystyle\|S, T\| := \sum_{v \in S} \sum_{w \in T} c(v \to w)\)
                        </p>
                    </div>

                    <div class="fragment" style="margin-top: 15px; padding: 10px; background: var(--bg-light); border-radius: 8px;">
                        <p class="small" style="color: var(--text-light);">
                            <strong>Note:</strong> The definition is asymmetric—edges from \(T\) to \(S\) are <em>not</em> counted.
                        </p>
                        <p class="small fragment" style="color: var(--text-light); margin-top: 5px;">
                            (If \(v \to w\) is not an edge, we assume \(c(v \to w) = 0\).)
                        </p>
                    </div>
                </section>

                <!-- Cut Example Slide -->
                <section>
                    <h2>Example: An (s,t)-cut</h2>
                    <div style="display: flex; justify-content: center; margin: 20px 0;">
                        <svg width="500" height="280" viewBox="0 0 500 280">
                            <!-- S region (teal/green) -->
                            <ellipse cx="140" cy="140" rx="120" ry="120" fill="rgba(0, 150, 136, 0.15)" stroke="var(--accent)" stroke-width="2"/>
                            <text x="40" y="260" fill="var(--accent)" font-size="24" font-weight="bold">S</text>

                            <!-- T region (red/pink) -->
                            <ellipse cx="360" cy="140" rx="120" ry="120" fill="rgba(231, 76, 60, 0.15)" stroke="#e74c3c" stroke-width="2"/>
                            <text x="460" y="260" fill="#e74c3c" font-size="24" font-weight="bold">T</text>

                            <!-- Edges -->
                            <!-- s to top-left in S -->
                            <line x1="100" y1="140" x2="160" y2="60" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="115" y="90" fill="var(--text)" font-size="14">20</text>

                            <!-- s to bottom-left in S -->
                            <line x1="100" y1="140" x2="160" y2="220" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="115" y="195" fill="var(--text)" font-size="14">10</text>

                            <!-- top-left to top-right (crosses cut - red) -->
                            <line x1="170" y1="60" x2="300" y2="60" stroke="#e74c3c" stroke-width="3" marker-end="url(#cutArrowRed)"/>
                            <text x="230" y="50" fill="#e74c3c" font-size="14" font-weight="bold">5</text>

                            <!-- bottom-right to top-left (crosses cut T→S - does NOT count) -->
                            <line x1="300" y1="210" x2="180" y2="75" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="220" y="155" fill="var(--text)" font-size="14">15</text>

                            <!-- bottom-left to bottom-right (crosses cut - red) -->
                            <line x1="170" y1="220" x2="300" y2="220" stroke="#e74c3c" stroke-width="3" marker-end="url(#cutArrowRed)"/>
                            <text x="230" y="245" fill="#e74c3c" font-size="14" font-weight="bold">10</text>

                            <!-- top-right to t -->
                            <line x1="320" y1="60" x2="400" y2="140" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="370" y="85" fill="var(--text)" font-size="14">15</text>

                            <!-- bottom-right to top-right -->
                            <line x1="310" y1="210" x2="310" y2="70" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="318" y="140" fill="var(--text)" font-size="14">10</text>

                            <!-- bottom-right to t -->
                            <line x1="320" y1="220" x2="400" y2="140" stroke="#666" stroke-width="2" marker-end="url(#cutArrow)"/>
                            <text x="370" y="195" fill="var(--text)" font-size="14">20</text>

                            <!-- Nodes -->
                            <circle cx="100" cy="140" r="20" fill="var(--accent)" stroke="var(--bg)" stroke-width="2"/>
                            <text x="100" y="145" fill="white" font-size="14" text-anchor="middle" font-weight="bold">s</text>

                            <circle cx="170" cy="60" r="15" fill="var(--bg-light)" stroke="var(--accent)" stroke-width="2"/>
                            <circle cx="170" cy="220" r="15" fill="var(--bg-light)" stroke="var(--accent)" stroke-width="2"/>

                            <circle cx="310" cy="60" r="15" fill="var(--bg-light)" stroke="#e74c3c" stroke-width="2"/>
                            <circle cx="310" cy="220" r="15" fill="var(--bg-light)" stroke="#e74c3c" stroke-width="2"/>

                            <circle cx="400" cy="140" r="20" fill="#e74c3c" stroke="var(--bg)" stroke-width="2"/>
                            <text x="400" y="145" fill="white" font-size="14" text-anchor="middle" font-weight="bold">t</text>

                            <!-- Arrow markers -->
                            <defs>
                                <marker id="cutArrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#666"/>
                                </marker>
                                <marker id="cutArrowRed" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#e74c3c"/>
                                </marker>
                            </defs>
                        </svg>
                    </div>
                    <p style="text-align: center; color: var(--text-light); font-size: 0.9em;">
                        Capacity of this cut: <span style="color: #e74c3c; font-weight: bold;">\(5 + 10 = 15\)</span>
                    </p>
                    <p class="fragment small" style="text-align: center; margin-top: 10px;">
                        <em>Red edges cross from \(S\) to \(T\) — only these count toward cut capacity</em>
                    </p>
                </section>

                <!-- Minimum Cut Problem Slide -->
                <section>
                    <h2>The Minimum Cut Problem</h2>
                    <div class="definition-box goal-box">
                        <p><strong>Minimum Cut Problem:</strong></p>
                        <p style="margin-top: 10px;">
                            Given a flow network \((G, s, t, c)\), compute an \((s,t)\)-cut whose capacity is as small as possible.
                        </p>
                    </div>

                    <div class="fragment" style="margin-top: 30px; padding: 15px; background: var(--bg-light); border-radius: 8px; border-left: 4px solid var(--accent); max-width: 92%;">
                        <p style="font-size: 0.9em;">
                            <strong>Intuition:</strong> The minimum cut is the "cheapest bottleneck" — the smallest-capacity set of edges whose removal disconnects \(s\) from \(t\).
                        </p>
                    </div>

                    <p class="fragment" style="margin-top: 25px; color: var(--text-light);">
                        What's the relationship between maximum flows and minimum cuts?
                    </p>
                </section>

                <!-- Max-Flow Min-Cut Lemma Statement -->
                <section>
                    <h2>Flows vs. Cuts</h2>
                    <div class="definition-box" style="border-left-color: var(--accent);">
                        <p><strong>Lemma:</strong> Let \(f\) be <em>any</em> feasible \((s,t)\)-flow, and let \((S, T)\) be <em>any</em> \((s,t)\)-cut.</p>
                        <p class="fragment" style="margin-top: 15px; font-size: 1.1em; text-align: center;">
                            \(|f| \leq \|S, T\|\)
                        </p>
                        <p class="fragment" style="margin-top: 10px; color: var(--text-light); font-size: 0.9em;">
                            The value of any flow is at most the capacity of any cut.
                        </p>
                    </div>

                    <div class="fragment" style="margin-top: 25px;">
                        <p><strong>Moreover:</strong> \(|f| = \|S, T\|\) if and only if:</p>
                        <ul style="margin-top: 10px;">
                            <li class="fragment">\(f\) <strong>saturates</strong> every edge from \(S\) to \(T\), and</li>
                            <li class="fragment">\(f\) <strong>avoids</strong> every edge from \(T\) to \(S\)</li>
                        </ul>
                    </div>
                </section>

                <!-- Proof Slide (Combined) -->
                <section>
                    <h2>Proof: Flows ≤ Cuts</h2>
                    <p style="font-size: 0.8em; color: var(--text-light); margin-bottom: 12px;">
                        Pick any flow \(f\) and any cut \((S, T)\). Follow the bouncing equalities:
                    </p>

                    <div style="font-size: 0.72em; line-height: 1.5;">
                        <div style="margin-bottom: 10px;">
                            <span>\(|f| = \partial f(s)\)</span>
                            <span class="fragment" style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[by definition]</span>
                        </div>

                        <div class="fragment" style="margin-bottom: 10px;">
                            <span>\(\displaystyle = \sum_{v \in S} \partial f(v)\)</span>
                            <span style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[conservation]</span>
                        </div>

                        <div class="fragment" style="margin-bottom: 10px;">
                            <span>\(\displaystyle = \sum_{v \in S}\sum_{w} f(v \to w) - \sum_{v \in S}\sum_{u} f(u \to v)\)</span>
                            <span style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[expand \(\partial\)]</span>
                        </div>

                        <div class="fragment" style="margin-bottom: 10px;">
                            <span>\(\displaystyle = \sum_{v \in S}\sum_{w \in T} f(v \to w) - \sum_{v \in S}\sum_{u \in T} f(u \to v)\)</span>
                            <span style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[edges in \(S\) cancel]</span>
                        </div>

                        <div class="fragment" style="margin-bottom: 10px;">
                            <span>\(\displaystyle \leq \sum_{v \in S}\sum_{w \in T} f(v \to w)\)</span>
                            <span style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[since \(f(u \to v) \geq 0\)]</span>
                        </div>

                        <div class="fragment" style="margin-bottom: 10px;">
                            <span>\(\displaystyle \leq \sum_{v \in S}\sum_{w \in T} c(v \to w) = \|S, T\|\)</span>
                            <span style="color: var(--text-light); margin-left: 25px; font-size: 0.85em;">[since \(f(e) \leq c(e)\)]</span>
                        </div>
                    </div>

                    <div class="fragment" style="margin-top: 18px; padding: 10px 25px; background: rgba(0, 150, 136, 0.1); border-radius: 8px; border: 1px solid var(--accent); display: inline-block;">
                        <p style="font-size: 0.8em; text-align: center; margin: 0;">
                            \(\boxed{|f| \leq \|S, T\|}\) for any flow \(f\) and any cut \((S, T)\) ✓
                        </p>
                    </div>
                </section>

                <!-- Corollary Slide -->
                <section>
                    <h2>The Max-Flow Min-Cut Theorem</h2>
                    <div class="definition-box" style="border-left-color: var(--accent);">
                        <p><strong>Corollary:</strong></p>
                        <p class="fragment" style="margin-top: 10px;">
                            If we find a flow \(f^*\) and a cut \((S^*, T^*)\) with \(|f^*| = \|S^*, T^*\|\), then:
                        </p>
                        <ul style="margin-top: 10px;">
                            <li class="fragment">\(f^*\) is a <strong>maximum flow</strong></li>
                            <li class="fragment">\((S^*, T^*)\) is a <strong>minimum cut</strong></li>
                        </ul>
                    </div>

                    <div class="fragment" style="margin-top: 25px; padding: 15px; background: var(--bg-light); border-radius: 8px;">
                        <p style="font-size: 0.95em; text-align: center; color: var(--accent); font-weight: bold;">
                            Max Flow = Min Cut
                        </p>
                        <p class="fragment small" style="text-align: center; margin-top: 8px; color: var(--text-light);">
                            The Ford-Fulkerson algorithm finds both simultaneously!
                        </p>
                    </div>
                </section>

                <!-- Video: Flows -->
                <section>
                    <h2>Further Viewing</h2>
                    <div style="display: flex; justify-content: center; align-items: center;">
                        <a href="https://www.youtube.com/watch?v=LdOnanfc5TM" target="_blank" style="position: relative; display: inline-block;">
                            <img src="https://img.youtube.com/vi/LdOnanfc5TM/hqdefault.jpg" alt="Introduction to Max Flow" style="width: 640px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 68px; height: 48px; background: rgba(255,0,0,0.8); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                                <div style="width: 0; height: 0; border-left: 20px solid white; border-top: 12px solid transparent; border-bottom: 12px solid transparent; margin-left: 4px;"></div>
                            </div>
                        </a>
                    </div>
                    <p class="small" style="text-align: center; margin-top: 15px; color: var(--text-light);">
                        Introduction to Max Flow <span style="color: var(--accent);">(click to open)</span>
                    </p>
                </section>
            </section>

            <!-- ===== SECTION 3: Reducing to Max Flow or Min Cut ===== -->
            <section>
                <section class="section-title">
                    <h1>Reducing to Max Flow or Min Cut</h1>
                </section>

                <!-- IPL Elimination Subsection Title -->
                <section>
                    <h2 style="font-size: 1.6em; color: var(--accent);">Can RCB make it to the top of the IPL league table?</h2>
                    <div style="display: flex; justify-content: center; gap: 20px; margin: 30px 0;">
                        <img src="../../assets/images/rcb-logo.png" alt="RCB Logo" style="height: 120px; width: auto;">
                    </div>
                    <p class="fragment" style="font-size: 1.1em; color: var(--text-light);">
                        A classic application of max-flow: <strong>Sports Elimination</strong>
                    </p>
                    <p class="fragment small" style="margin-top: 20px;">
                        Given the current standings and remaining matches,<br>
                        is it <em>mathematically possible</em> for a team to finish at the top?
                    </p>
                </section>

                <!-- Problem Setup -->
                <section>
                    <h2>The IPL Elimination Problem</h2>
                    <div style="max-width: 70%;">
                        <p><strong>Input:</strong></p>
                        <ul style="font-size: 0.95em;">
                            <li class="fragment">Current wins for each team</li>
                            <li class="fragment">Remaining matches between teams</li>
                            <li class="fragment">A target team (e.g., RCB)</li>
                        </ul>
                        <p class="fragment" style="margin-top: 20px;"><strong>Question:</strong></p>
                        <p class="fragment" style="color: var(--accent);">
                            Can remaining matches be played such that the target team finishes with at least as many wins as every other team?
                        </p>
                        <p class="fragment" style="margin-top: 20px;"><strong>Assumption:</strong></p>
                        <p class="fragment" style="font-size: 0.9em; color: var(--text-light);">
                            We assume the target team wins <em>all</em> its remaining matches. This gives us their maximum possible final score:
                        </p>
                        <p class="fragment" style="text-align: center; margin: 10px 0; font-size: 1.1em;">
                            $X = w_{\text{target}} + r_{\text{target}}$
                        </p>
                    </div>
                </section>

                <!-- Interactive IPL Standings -->
                <section>
                    <h2>IPL Standings Scenario</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <div class="demo-header">
                            <span class="demo-title">Interactive IPL Elimination</span>
                            <div class="demo-controls">
                                <button class="btn btn-secondary" onclick="resetIPLDemo()">Reset</button>
                                <button class="btn btn-primary" onclick="randomIPLInstance()">New Instance</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 15px; align-items: flex-start;">
                            <!-- Target Score -->
                            <div style="flex: 0.6; text-align: center;">
                                <div style="background: #EC1C2415; padding: 12px; border-radius: 8px; border: 2px solid #EC1C24;">
                                    <p style="font-size: 0.85em; color: #666; margin-bottom: 4px;">Target Score</p>
                                    <p style="font-size: 2em; font-weight: 700; color: #EC1C24; margin: 0;" id="target-x">11</p>
                                    <p style="font-size: 0.8em; color: #888; margin-top: 4px;">No team can exceed this</p>
                                </div>
                                <button class="btn" onclick="declareHopeless()" style="margin-top: 10px; background: #666; color: white; padding: 8px 12px; font-size: 0.85em;">Declare Hopeless</button>
                            </div>
                            <!-- Current Standings -->
                            <div style="flex: 1;">
                                <p style="font-weight: 600; font-size: 0.9em; margin-bottom: 8px;">Current Wins:</p>
                                <div id="ipl-standings-cards" style="display: flex; flex-direction: column; gap: 6px;"></div>
                            </div>
                            <!-- Remaining Matches -->
                            <div style="flex: 1.4;">
                                <p style="font-weight: 600; font-size: 0.9em; margin-bottom: 8px;">Remaining Matches (click to assign winner):</p>
                                <div id="ipl-matches" style="display: flex; flex-direction: column; gap: 8px;"></div>
                            </div>
                        </div>
                        <div class="demo-output" id="ipl-commentary">
                            Assign winners to the remaining matches. Can you keep every team at or below the target?
                        </div>
                    </div>
                </section>

                <!-- Simple vs Non-trivial Elimination -->
                <section>
                    <h2>Types of Elimination</h2>
                    <div style="display: flex; flex-direction: column; gap: 20px; max-width: 85%;">
                        <div class="fragment" style="background: #f0fff0; padding: 15px 20px; border-radius: 8px; border: 2px solid #90EE90;">
                            <h3 style="color: #228B22; font-size: 1.1em; margin-bottom: 8px;">Trivial Elimination</h3>
                            <p style="font-size: 0.9em; margin: 0;">
                                Some team already has more wins than our maximum possible:
                                <span style="margin-left: 15px;">$\exists$ team $i$: $w_i > X$</span>
                                <span style="color: var(--text-light); margin-left: 15px;"><em>— Easy to detect!</em></span>
                            </p>
                        </div>
                        <div class="fragment" style="background: #fff0f0; padding: 15px 20px; border-radius: 8px; border: 2px solid #FFB6C1;">
                            <h3 style="color: #DC143C; font-size: 1.1em; margin-bottom: 8px;">Non-trivial Elimination</h3>
                            <p style="font-size: 0.9em; margin: 0;">
                                No single team beats us, but a <em>group</em> of teams must play each other and <em>someone</em> will exceed $X$.
                            </p>
                            <p style="font-size: 0.95em; margin: 10px 0 0 0;">
                                <span>$\forall i$: $w_i \leq X$, yet eliminated!</span>
                                <span style="color: var(--text-light); margin-left: 15px;"><em>— Requires careful analysis...</em></span>
                            </p>
                        </div>
                    </div>
                </section>

                <!-- Flow Network Construction -->
                <section>
                    <h2>Reducing to Max Flow</h2>
                    <p style="margin-bottom: 15px;">Construct a flow network to determine if team $z$ (RCB) is eliminated:</p>
                    <div style="display: flex; gap: 20px; font-size: 0.9em;">
                        <div class="fragment" style="flex: 1; background: var(--bg-light); padding: 15px; border-radius: 8px;">
                            <p><strong>Vertices:</strong></p>
                            <ul style="margin-top: 8px;">
                                <li>Source $s$ and sink $t$</li>
                                <li>One vertex per team pair $(i,j)$</li>
                                <li>One vertex per team $i \neq z$</li>
                            </ul>
                        </div>
                        <div class="fragment" style="flex: 1; background: var(--bg-light); padding: 15px; border-radius: 8px;">
                            <p><strong>Edges:</strong></p>
                            <ul style="margin-top: 8px;">
                                <li>$s \to (i,j)$: capacity $= g_{ij}$</li>
                                <li>$(i,j) \to i$ and $(i,j) \to j$: $\infty$</li>
                                <li>$i \to t$: capacity $= X - w_i$</li>
                            </ul>
                        </div>
                    </div>
                    <div class="definition-box goal-box fragment" style="margin-top: 20px;">
                        <p><strong>Theorem:</strong> Team $z$ is <em>not</em> eliminated iff max flow saturates all edges from $s$.</p>
                        <p class="small" style="color: var(--text-light);">i.e., flow value $= \sum_{i < j} g_{ij}$ (total remaining games among other teams)</p>
                    </div>
                </section>

                <!-- Interactive Flow Network Builder -->
                <section>
                    <h2>Building the Flow Network</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <!-- Phase 1: Input Form -->
                        <div id="fb-input-phase">
                            <div class="demo-header">
                                <span class="demo-title">Configure Instance</span>
                                <div class="demo-controls">
                                    <button class="btn btn-secondary" onclick="randomFlowBuilderInstance()">🎲 Random</button>
                                    <button class="btn btn-primary" onclick="startFlowBuilder()">Build Network →</button>
                                </div>
                            </div>
                            <div style="display: flex; gap: 25px; padding: 15px; background: #fafafa; border-radius: 6px;">
                                <!-- Wins input -->
                                <div style="flex: 1;">
                                    <p style="font-weight: 600; margin-bottom: 10px; font-size: 0.9em;">Current Wins</p>
                                    <div style="display: flex; gap: 10px;">
                                        <div style="text-align: center;">
                                            <div style="background: #004BA0; color: #FFD700; padding: 4px 10px; border-radius: 4px 4px 0 0; font-size: 0.8em; font-weight: 600;">MI</div>
                                            <input type="number" id="fb-input-wins-mi" value="10" min="0" max="14" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="background: #FFCB05; color: #0066B3; padding: 4px 10px; border-radius: 4px 4px 0 0; font-size: 0.8em; font-weight: 600;">CSK</div>
                                            <input type="number" id="fb-input-wins-csk" value="11" min="0" max="14" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="background: #3A225D; color: #FFD700; padding: 4px 10px; border-radius: 4px 4px 0 0; font-size: 0.8em; font-weight: 600;">KKR</div>
                                            <input type="number" id="fb-input-wins-kkr" value="9" min="0" max="14" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                    </div>
                                </div>
                                <!-- Remaining matches input -->
                                <div style="flex: 1;">
                                    <p style="font-weight: 600; margin-bottom: 10px; font-size: 0.9em;">Remaining Matches</p>
                                    <div style="display: flex; gap: 10px;">
                                        <div style="text-align: center;">
                                            <div style="background: #666; color: white; padding: 4px 8px; border-radius: 4px 4px 0 0; font-size: 0.75em;">MI-CSK</div>
                                            <input type="number" id="fb-input-games-mi-csk" value="1" min="0" max="7" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="background: #666; color: white; padding: 4px 8px; border-radius: 4px 4px 0 0; font-size: 0.75em;">MI-KKR</div>
                                            <input type="number" id="fb-input-games-mi-kkr" value="1" min="0" max="7" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="background: #666; color: white; padding: 4px 8px; border-radius: 4px 4px 0 0; font-size: 0.75em;">CSK-KKR</div>
                                            <input type="number" id="fb-input-games-csk-kkr" value="1" min="0" max="7" style="width: 50px; padding: 6px; text-align: center; border: 1px solid #ddd; border-radius: 0 0 4px 4px; font-size: 1em;">
                                        </div>
                                    </div>
                                </div>
                                <!-- Target X input -->
                                <div style="flex: 0 0 auto;">
                                    <p style="font-weight: 600; margin-bottom: 10px; font-size: 0.9em;">Target Score</p>
                                    <div style="text-align: center;">
                                        <div style="background: #EC1C24; color: white; padding: 4px 12px; border-radius: 4px 4px 0 0; font-size: 0.8em; font-weight: 600;">X</div>
                                        <input type="number" id="fb-input-target" value="11" min="0" max="14" style="width: 60px; padding: 6px; text-align: center; border: 2px solid #EC1C24; border-radius: 0 0 4px 4px; font-size: 1.1em; font-weight: 600;">
                                    </div>
                                </div>
                            </div>
                            <div class="demo-output" style="margin-top: 10px;">
                                Enter your instance or click <strong>🎲 Random</strong> to generate one, then click <strong>Build Network →</strong> to visualize.
                            </div>
                        </div>

                        <!-- Phase 2: Step-by-Step Visualization (hidden initially) -->
                        <div id="fb-build-phase" style="display: none;">
                            <div class="demo-header">
                                <span class="demo-title">Step-by-Step Construction</span>
                                <div class="demo-controls">
                                    <button class="btn btn-secondary" onclick="resetFlowBuilder()">← New Instance</button>
                                    <button class="btn btn-primary" id="flow-next-btn" onclick="flowBuilderNextStep()">Next Step</button>
                                </div>
                            </div>
                            <!-- Canvas for the graph -->
                            <div id="flow-builder-canvas" style="display: flex; justify-content: center; align-items: center; min-height: 300px; background: #fafafa; border-radius: 6px;">
                                <svg id="flow-builder-svg" width="750" height="290" viewBox="0 0 750 290" style="font-family: 'Heliotrope', Georgia, serif;">
                                    <defs>
                                        <marker id="arrowhead3" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" fill="#555"/>
                                        </marker>
                                    </defs>
                                </svg>
                            </div>
                            <!-- Data table -->
                            <div style="margin-top: 12px; display: flex; gap: 20px; align-items: center; justify-content: center; flex-wrap: wrap;">
                                <table id="flow-builder-table" style="border-collapse: collapse; font-size: 0.85em;">
                                    <thead>
                                        <tr style="background: var(--bg-light);">
                                            <th style="padding: 6px 12px; border: 1px solid #ddd;"></th>
                                            <th style="padding: 6px 12px; border: 1px solid #ddd; background: #004BA0; color: #FFD700;">MI</th>
                                            <th style="padding: 6px 12px; border: 1px solid #ddd; background: #FFCB05; color: #0066B3;">CSK</th>
                                            <th style="padding: 6px 12px; border: 1px solid #ddd; background: #3A225D; color: #FFD700;">KKR</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td style="padding: 6px 12px; border: 1px solid #ddd; font-weight: 600;">Wins</td>
                                            <td id="fb-wins-mi" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">10</td>
                                            <td id="fb-wins-csk" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">11</td>
                                            <td id="fb-wins-kkr" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">9</td>
                                        </tr>
                                        <tr>
                                            <td style="padding: 6px 12px; border: 1px solid #ddd; font-weight: 600;">Slack (X−w)</td>
                                            <td id="fb-slack-mi" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">1</td>
                                            <td id="fb-slack-csk" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">0</td>
                                            <td id="fb-slack-kkr" style="padding: 6px 12px; border: 1px solid #ddd; text-align: center;">2</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div style="background: #EC1C2420; padding: 8px 16px; border-radius: 6px; border: 2px solid #EC1C24;">
                                    <span style="font-size: 0.85em; color: #666;">Target X = </span>
                                    <span id="fb-target-x" style="font-size: 1.3em; font-weight: 700; color: #EC1C24;">11</span>
                                </div>
                                <div style="background: #f0f0f0; padding: 8px 16px; border-radius: 6px;">
                                    <span style="font-size: 0.85em; color: #666;">Remaining games: </span>
                                    <span id="fb-total-games" style="font-weight: 600;">3</span>
                                </div>
                            </div>
                            <div class="demo-output" id="flow-builder-commentary">
                                Step 0: Start with source <strong>s</strong> and sink <strong>t</strong>. Click "Next Step" to build the network.
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Why it Works -->
                <section>
                    <h2>Why Does This Work?</h2>
                    <div style="font-size: 0.95em;">
                        <div class="fragment" style="background: var(--bg-light); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <p><strong>Flow Interpretation:</strong></p>
                            <ul style="margin-top: 8px;">
                                <li>Flow on $s \to (i,j)$: how many of those games are "assigned"</li>
                                <li>Flow on $(i,j) \to i$: games from $(i,j)$ that team $i$ wins</li>
                                <li>Flow on $i \to t$: total additional wins for team $i$</li>
                            </ul>
                        </div>
                        <div class="fragment" style="background: var(--bg-light); padding: 15px; border-radius: 8px;">
                            <p><strong>Capacity Constraint at $i \to t$:</strong></p>
                            <p style="margin-top: 8px;">
                                Team $i$ can receive at most $X - w_i$ additional wins.<br>
                                This ensures $w_i + (\text{new wins}) \leq X$.
                            </p>
                        </div>
                        <div class="fragment definition-box" style="margin-top: 15px; border-left-width: 4px; border-left-style: solid; border-left-color: var(--pastel-coral);">
                            <p><strong>Key Insight:</strong> If max flow $<$ total remaining games, some game <em>cannot</em> be assigned without pushing a team past $X$ wins. RCB is eliminated!</p>
                        </div>
                    </div>
                </section>

                <!-- Certificate of Elimination -->
                <section>
                    <h2>Certificate of Elimination</h2>
                    <p style="margin-bottom: 15px;">When eliminated, the <strong>min-cut</strong> provides a <em>proof</em>:</p>
                    <div style="display: flex; gap: 25px;">
                        <div class="fragment" style="flex: 1;">
                            <div class="definition-box" style="background: #fff8e8; border-left: 4px solid #f0ad4e;">
                                <p><strong>The Blocking Subset:</strong></p>
                                <p style="font-size: 0.9em; margin-top: 8px;">
                                    Let $S$ be the teams reachable from $s$ in the residual graph.
                                </p>
                                <p style="font-size: 0.9em; margin-top: 8px;">
                                    Then for teams in $S$:
                                </p>
                                <p style="text-align: center; margin: 10px 0;">
                                    $\displaystyle\frac{w(S) + g(S)}{|S|} > X$
                                </p>
                                <p class="small" style="color: var(--text-light);">
                                    where $w(S) = \sum_{i \in S} w_i$ and $g(S) = \sum_{i,j \in S} g_{ij}$
                                </p>
                            </div>
                        </div>
                        <div class="fragment" style="flex: 1;">
                            <div style="background: var(--bg-light); padding: 15px; border-radius: 8px;">
                                <p style="font-size: 0.9em;"><strong>In plain English:</strong></p>
                                <p style="font-size: 0.85em; margin-top: 10px; color: var(--text-light);">
                                    Teams in $S$ play so many games among themselves that their <em>average</em> wins must exceed $X$.
                                </p>
                                <p style="font-size: 0.85em; margin-top: 10px; color: var(--text-light);">
                                    So at least one team beats $X$ — RCB can't finish on top.
                                </p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Interactive Certificate Demo -->
                <section>
                    <h2>Finding the Certificate</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <div class="demo-header">
                            <span class="demo-title">Certificate of Elimination</span>
                            <div class="demo-controls">
                                <button class="btn btn-secondary" onclick="newCertificateInstance()">🎲 New Instance</button>
                                <button class="btn btn-primary" id="cert-reveal-btn" onclick="revealCertificate()">Reveal Certificate</button>
                            </div>
                        </div>
                        <!-- Instance display -->
                        <div style="display: flex; gap: 15px; padding: 10px; background: #fafafa; border-radius: 6px; margin-bottom: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">
                            <table id="cert-instance-table" style="border-collapse: collapse; font-size: 0.8em;">
                                <thead>
                                    <tr style="background: var(--bg-light);">
                                        <th style="padding: 5px 10px; border: 1px solid #ddd;"></th>
                                        <th style="padding: 5px 10px; border: 1px solid #ddd; background: #004BA0; color: #FFD700;">MI</th>
                                        <th style="padding: 5px 10px; border: 1px solid #ddd; background: #FFCB05; color: #0066B3;">CSK</th>
                                        <th style="padding: 5px 10px; border: 1px solid #ddd; background: #3A225D; color: #FFD700;">KKR</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 5px 10px; border: 1px solid #ddd; font-weight: 600;">Wins</td>
                                        <td id="cert-wins-mi" style="padding: 5px 10px; border: 1px solid #ddd; text-align: center;">10</td>
                                        <td id="cert-wins-csk" style="padding: 5px 10px; border: 1px solid #ddd; text-align: center;">9</td>
                                        <td id="cert-wins-kkr" style="padding: 5px 10px; border: 1px solid #ddd; text-align: center;">8</td>
                                    </tr>
                                </tbody>
                            </table>
                            <table id="cert-games-table" style="border-collapse: collapse; font-size: 0.8em;">
                                <thead>
                                    <tr style="background: #eee;">
                                        <th style="padding: 5px 8px; border: 1px solid #ddd;">MI-CSK</th>
                                        <th style="padding: 5px 8px; border: 1px solid #ddd;">MI-KKR</th>
                                        <th style="padding: 5px 8px; border: 1px solid #ddd;">CSK-KKR</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td id="cert-games-mi-csk" style="padding: 5px 8px; border: 1px solid #ddd; text-align: center;">2</td>
                                        <td id="cert-games-mi-kkr" style="padding: 5px 8px; border: 1px solid #ddd; text-align: center;">1</td>
                                        <td id="cert-games-csk-kkr" style="padding: 5px 8px; border: 1px solid #ddd; text-align: center;">2</td>
                                    </tr>
                                </tbody>
                            </table>
                            <div style="background: #EC1C2420; padding: 6px 14px; border-radius: 6px; border: 2px solid #EC1C24;">
                                <span style="font-size: 0.8em; color: #666;">X = </span>
                                <span id="cert-target-x" style="font-size: 1.2em; font-weight: 700; color: #EC1C24;">10</span>
                            </div>
                        </div>
                        <!-- Certificate reveal area -->
                        <div id="cert-reveal-area" style="display: none;">
                            <div style="display: flex; gap: 20px; padding: 10px;">
                                <div style="flex: 1;">
                                    <p style="font-size: 0.9em; margin-bottom: 10px;"><strong>Blocking Subset $S$:</strong></p>
                                    <div id="certificate-teams" style="display: flex; gap: 10px; flex-wrap: wrap;"></div>
                                    <div style="margin-top: 12px; background: #f8f8f8; padding: 10px; border-radius: 6px;">
                                        <p style="font-size: 0.85em;"><strong>Calculation:</strong></p>
                                        <div id="certificate-calc" style="font-size: 0.85em; margin-top: 8px;"></div>
                                    </div>
                                </div>
                                <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                    <div id="certificate-visual" style="width: 100%; height: 190px; background: #fff8e8; border: 2px solid #f0ad4e; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                                        <svg id="cert-svg" width="320" height="175" viewBox="0 0 320 175"></svg>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="demo-output" id="certificate-result">
                            This instance is <strong>doomed</strong> — the target team is eliminated! Click <strong>Reveal Certificate</strong> to see why.
                        </div>
                    </div>
                </section>

                <!-- Summary -->
                <section>
                    <h2>Sports Elimination: Summary</h2>
                    <div style="font-size: 0.95em;">
                        <div class="fragment" style="margin-bottom: 15px;">
                            <p><strong>The Reduction:</strong></p>
                            <p style="margin-left: 20px;">Sports Elimination $\leq_P$ Max Flow</p>
                        </div>
                        <div class="fragment" style="margin-bottom: 15px;">
                            <p><strong>Complexity:</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>$O(n^2)$ vertices, $O(n^2)$ edges</li>
                                <li>Solvable in $O(n^4)$ time via max flow</li>
                                <li>Kevin Wayne (2001): All eliminations in $O(n^3)$ time!</li>
                            </ul>
                        </div>
                        <div class="fragment definition-box goal-box">
                            <p><strong>Takeaway:</strong> A problem that seems to require exhaustive search over all possible game outcomes reduces elegantly to a single max-flow computation.</p>
                        </div>
                    </div>
                </section>

                <!-- Video: Sports Elimination -->
                <section>
                    <h2>Further Viewing</h2>
                    <div style="display: flex; justify-content: center; align-items: center;">
                        <a href="https://www.youtube.com/watch?v=XK6qZjHWo9A" target="_blank" style="position: relative; display: inline-block;">
                            <img src="https://img.youtube.com/vi/XK6qZjHWo9A/hqdefault.jpg" alt="Baseball Elimination Problem" style="width: 640px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 68px; height: 48px; background: rgba(255,0,0,0.8); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                                <div style="width: 0; height: 0; border-left: 20px solid white; border-top: 12px solid transparent; border-bottom: 12px solid transparent; margin-left: 4px;"></div>
                            </div>
                        </a>
                    </div>
                    <p class="small" style="text-align: center; margin-top: 15px; color: var(--text-light);">
                        Baseball Elimination Problem <span style="color: var(--accent);">(click to open)</span>
                    </p>
                </section>

                <!-- ===== Election Problem ===== -->
                <!-- Introduction -->
                <section>
                    <h2>The Election Problem</h2>
                    <div style="font-size: 0.9em; max-width: 95%;">
                        <p style="margin-bottom: 20px;">A community holds an election between <span style="color: #3B82F6; font-weight: 600;">Candidate A</span> and <span style="color: #EF4444; font-weight: 600;">Candidate B</span>.</p>

                        <div class="fragment" style="background: var(--bg-light); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                            <p><strong>Each person has:</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>A <em>personal preference</em> for one candidate</li>
                                <li><em>Friendships</em> with other people in the community</li>
                            </ul>
                        </div>

                        <div class="fragment" style="background: #FEF3C7; padding: 12px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #F59E0B;">
                            <p><strong>The Conflict:</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>Voting <em>against</em> your preference incurs a <strong>preference penalty</strong></li>
                                <li>Friends voting <em>differently</em> incurs a <strong>friendship penalty</strong></li>
                            </ul>
                        </div>

                        <div class="fragment definition-box goal-box" style="max-width: 90%;">
                            <p><strong>Goal:</strong> Find a voting assignment that minimizes total penalty.</p>
                        </div>
                    </div>
                </section>

                <!-- Formal Definition -->
                <section>
                    <h2>Formal Problem Definition</h2>
                    <div style="font-size: 0.9em; max-width: 95%; margin: 0 auto;">
                        <p><strong>Input:</strong></p>
                        <ul style="margin-left: 20px; margin-bottom: 15px;">
                            <li>$n$ people, each with preference for A or B</li>
                            <li>Preference penalty $p_i$ for person $i$ voting against their preference</li>
                            <li>Friendship pairs $(i,j)$ with penalty weight $w_{ij}$ for voting differently</li>
                        </ul>

                        <p><strong>Question:</strong></p>
                        <p style="margin-left: 20px;" class="fragment">Find assignment $f: \{1,\ldots,n\} \to \{A, B\}$ minimizing:</p>

                        <div class="fragment" style="text-align: center; background: #f0f4f8; padding: 12px; border-radius: 8px; margin: 15px auto; max-width: 90%; overflow-x: auto;">
                            $$\sum_{\substack{i:\; f(i) \neq \text{pref}(i)}} p_i \;+\; \sum_{\substack{(i,j):\; f(i) \neq f(j)}} w_{ij}$$
                        </div>

                        <p class="fragment" style="text-align: center; color: #666; font-size: 0.9em;">
                            (preference penalties) + (friendship penalties)
                        </p>
                    </div>
                </section>

                <!-- Why it's Min-Cut -->
                <section>
                    <h2>Why This is a Min-Cut Problem</h2>
                    <div style="font-size: 0.85em; max-width: 80%; margin: 0 auto;">
                        <p style="margin-bottom: 15px;">The key insight: this maps perfectly to finding a minimum $(s,t)$-cut!</p>

                        <table style="width: 100%; border-collapse: collapse; font-size: 0.8em; table-layout: fixed;">
                            <tr style="background: #e8f4f8;">
                                <th style="padding: 6px; border: 1px solid #ddd; text-align: left; width: 50%;">Real World</th>
                                <th style="padding: 6px; border: 1px solid #ddd; text-align: left; width: 50%;">Flow Network</th>
                            </tr>
                            <tr class="fragment">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;"><span style="color: #3B82F6;">A-preferring</span> people</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Connected to Source ($s$)</td>
                            </tr>
                            <tr class="fragment">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;"><span style="color: #EF4444;">B-preferring</span> people</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Connected to Sink ($t$)</td>
                            </tr>
                            <tr class="fragment">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Preference penalty $p_i$</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Capacity of edge from/to $s$/$t$</td>
                            </tr>
                            <tr class="fragment">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Friendship penalty $w_{ij}$</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Capacity of edges between $i$, $j$</td>
                            </tr>
                            <tr class="fragment" style="background: #f0fdf4;">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">People voting for A</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Nodes on <strong>Source side</strong> of cut</td>
                            </tr>
                            <tr class="fragment" style="background: #fef2f2;">
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">People voting for B</td>
                                <td style="padding: 5px 6px; border: 1px solid #ddd;">Nodes on <strong>Sink side</strong> of cut</td>
                            </tr>
                        </table>
                    </div>
                </section>

                <!-- Interactive Demo: Build Social Network -->
                <section>
                    <h2>Build Your Community</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <div class="demo-header">
                            <span class="demo-title">Social Network Builder</span>
                            <div class="demo-controls">
                                <select id="election-scenario" onchange="loadElectionScenario()" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ddd; font-size: 0.9em;">
                                    <option value="custom">Custom</option>
                                    <option value="dinner">The Dinner Party (4 people)</option>
                                    <option value="influencer">The Influencer (5 people)</option>
                                    <option value="communities">Two Communities (6 people)</option>
                                    <option value="swing">The Swing Voter (5 people)</option>
                                </select>
                                <button class="btn btn-secondary" onclick="clearElectionNetwork()">Clear</button>
                                <button class="btn btn-primary" onclick="buildElectionFlowNetwork()">Build Flow Network →</button>
                            </div>
                        </div>

                        <!-- Add/Edit Controls -->
                        <div style="display: flex; gap: 15px; padding: 10px; background: #fafafa; border-radius: 6px; margin-bottom: 10px; flex-wrap: wrap; align-items: center;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <button class="btn" style="background: #3B82F6; color: white; padding: 6px 12px;" onclick="addElectionPerson('A')">+ Person (prefers A)</button>
                                <button class="btn" style="background: #EF4444; color: white; padding: 6px 12px;" onclick="addElectionPerson('B')">+ Person (prefers B)</button>
                            </div>
                            <div style="border-left: 1px solid #ddd; padding-left: 15px; display: flex; gap: 8px; align-items: center;">
                                <label style="font-size: 0.85em; color: #666;">Mode:</label>
                                <button id="election-mode-select" class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.85em;" onclick="toggleElectionMode('select')">Select</button>
                                <button id="election-mode-connect" class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.85em;" onclick="toggleElectionMode('connect')">Connect Friends</button>
                                <button id="election-mode-delete" class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.85em;" onclick="toggleElectionMode('delete')">Delete</button>
                            </div>
                        </div>

                        <!-- Social Network Canvas -->
                        <div style="display: flex; gap: 15px;">
                            <div style="flex: 2; background: #f8f9fa; border-radius: 8px; border: 2px solid #e0e0e0; min-height: 280px; position: relative;">
                                <svg id="election-social-svg" width="100%" height="280" viewBox="0 0 420 280" preserveAspectRatio="xMidYMid meet" style="display: block;"></svg>
                            </div>

                            <!-- Properties Panel -->
                            <div id="election-props-panel" style="flex: 1; background: #fafafa; border-radius: 8px; padding: 12px; font-size: 0.85em; min-width: 180px;">
                                <p style="font-weight: 600; margin-bottom: 10px; color: #666;">Properties</p>
                                <div id="election-props-content">
                                    <p style="color: #999; font-style: italic;">Click a person or friendship to edit</p>
                                </div>
                            </div>
                        </div>

                        <div class="demo-output" id="election-social-output">
                            Add people and connect friends to build your community. Select a scenario or create your own!
                        </div>
                    </div>
                </section>

                <!-- Flow Network Visualization -->
                <section>
                    <h2>The Flow Network</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <div class="demo-header">
                            <span class="demo-title">Transformation to Flow Network</span>
                            <div class="demo-controls">
                                <button class="btn btn-secondary" onclick="resetElectionToSocial()">← Back to Social Network</button>
                                <button class="btn btn-primary" id="election-run-btn" onclick="runElectionMaxFlow()">Run Max-Flow →</button>
                            </div>
                        </div>

                        <!-- Side-by-side view -->
                        <div style="display: flex; gap: 10px;">
                            <!-- Social Network (small) -->
                            <div style="flex: 1; background: #f8f9fa; border-radius: 8px; padding: 8px; border: 1px solid #e0e0e0;">
                                <p style="font-size: 0.75em; text-align: center; color: #666; margin-bottom: 5px;">Social Network</p>
                                <svg id="election-social-mini" width="100%" height="180" viewBox="0 0 250 180" preserveAspectRatio="xMidYMid meet"></svg>
                            </div>

                            <!-- Flow Network -->
                            <div style="flex: 2; background: #f0f4f8; border-radius: 8px; padding: 8px; border: 2px solid #3B82F6;">
                                <p style="font-size: 0.75em; text-align: center; color: #3B82F6; margin-bottom: 5px; font-weight: 600;">Flow Network</p>
                                <svg id="election-flow-svg" width="100%" height="260" viewBox="0 0 600 260" preserveAspectRatio="xMidYMid meet"></svg>
                            </div>
                        </div>

                        <!-- Legend -->
                        <div style="display: flex; gap: 20px; justify-content: center; margin-top: 10px; font-size: 0.8em; flex-wrap: wrap;">
                            <span><span style="display: inline-block; width: 12px; height: 12px; background: #a8d4f0; border: 1px solid #333; border-radius: 50%; margin-right: 4px;"></span> Source (s) = "Vote A"</span>
                            <span><span style="display: inline-block; width: 12px; height: 12px; background: #f5c4c0; border: 1px solid #333; border-radius: 50%; margin-right: 4px;"></span> Sink (t) = "Vote B"</span>
                            <span><span style="display: inline-block; width: 20px; height: 3px; background: #3B82F6; margin-right: 4px; vertical-align: middle;"></span> Preference edge</span>
                            <span><span style="display: inline-block; width: 20px; height: 3px; background: #8B5CF6; margin-right: 4px; vertical-align: middle;"></span> Friendship edge</span>
                        </div>

                        <div class="demo-output" id="election-flow-output">
                            The flow network is ready. Click <strong>Run Max-Flow</strong> to find the optimal voting assignment.
                        </div>
                    </div>
                </section>

                <!-- Results & Min-Cut Visualization -->
                <section>
                    <h2>Optimal Voting Assignment</h2>
                    <div class="demo-container" style="max-width: 95%;">
                        <div class="demo-header">
                            <span class="demo-title">Min-Cut = Optimal Votes</span>
                            <div class="demo-controls">
                                <button class="btn btn-secondary" onclick="resetElectionToSocial()">← New Scenario</button>
                                <button class="btn btn-primary" onclick="toggleElectionWhatIf()">What If? Mode</button>
                            </div>
                        </div>

                        <!-- Results visualization -->
                        <div style="display: flex; gap: 15px;">
                            <!-- Cut visualization -->
                            <div style="flex: 2; background: linear-gradient(to right, #EBF5FF 0%, #EBF5FF 48%, #ddd 48%, #ddd 52%, #FEF2F2 52%, #FEF2F2 100%); border-radius: 8px; padding: 10px; min-height: 280px;">
                                <svg id="election-result-svg" width="100%" height="270" viewBox="0 0 500 270" preserveAspectRatio="xMidYMid meet"></svg>
                            </div>

                            <!-- Results panel -->
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 10px;">
                                <!-- Vote counts -->
                                <div style="background: #f0f4f8; border-radius: 8px; padding: 12px; text-align: center;">
                                    <p style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Election Results</p>
                                    <div style="display: flex; justify-content: center; gap: 20px;">
                                        <div>
                                            <div style="font-size: 1.8em; font-weight: 700; color: #3B82F6;" id="election-votes-a">0</div>
                                            <div style="font-size: 0.8em; color: #666;">Candidate A</div>
                                        </div>
                                        <div>
                                            <div style="font-size: 1.8em; font-weight: 700; color: #EF4444;" id="election-votes-b">0</div>
                                            <div style="font-size: 0.8em; color: #666;">Candidate B</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Penalty breakdown -->
                                <div style="background: #fffbeb; border-radius: 8px; padding: 12px; border: 1px solid #fcd34d;">
                                    <p style="font-size: 0.8em; color: #92400e; margin-bottom: 8px; font-weight: 600;">Penalty Breakdown</p>
                                    <div id="election-penalty-breakdown" style="font-size: 0.85em;"></div>
                                    <div style="border-top: 1px solid #fcd34d; margin-top: 8px; padding-top: 8px;">
                                        <strong>Total: <span id="election-total-penalty">0</span></strong>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- What-if mode (hidden by default) -->
                        <div id="election-whatif-panel" style="display: none; margin-top: 15px; background: #f0fdf4; border-radius: 8px; padding: 12px; border: 2px solid #10B981;">
                            <p style="font-weight: 600; color: #059669; margin-bottom: 10px;">What If? Mode — Click on people to toggle their votes</p>
                            <div style="display: flex; gap: 20px; align-items: center;">
                                <div>Your penalty: <strong id="election-user-penalty">0</strong></div>
                                <div>Optimal penalty: <strong id="election-opt-penalty">0</strong></div>
                                <div>Difference: <span id="election-diff-penalty" style="font-weight: 600;">0</span></div>
                                <button class="btn btn-secondary" onclick="resetElectionWhatIf()" style="margin-left: auto;">Reset to Optimal</button>
                            </div>
                        </div>

                        <div class="demo-output" id="election-result-output">
                            The minimum cut determines the optimal voting assignment with minimum total penalty.
                        </div>
                    </div>
                </section>

                <!-- Election Problem Summary -->
                <section>
                    <h2>Election Problem: Summary</h2>
                    <div style="font-size: 0.95em;">
                        <div class="fragment" style="margin-bottom: 15px;">
                            <p><strong>The Reduction:</strong></p>
                            <p style="margin-left: 20px;">Election Problem $\leq_P$ Min Cut</p>
                        </div>
                        <div class="fragment" style="margin-bottom: 15px;">
                            <p><strong>Key Insight:</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>Cutting an edge from $s$ = A-supporter votes B (pays preference penalty)</li>
                                <li>Cutting an edge to $t$ = B-supporter votes A (pays preference penalty)</li>
                                <li>Cutting a friendship edge = friends vote differently (pays friendship penalty)</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Video: Election Problem / Min-Cut -->
                <section>
                    <h2>Further Viewing</h2>
                    <div style="display: flex; justify-content: center; align-items: center;">
                        <a href="https://www.youtube.com/watch?v=lCPvFXgH53s&t=5024s" target="_blank" style="position: relative; display: inline-block;">
                            <img src="https://img.youtube.com/vi/lCPvFXgH53s/hqdefault.jpg" alt="Introduction to Flows - Election Problem" style="width: 640px; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 68px; height: 48px; background: rgba(255,0,0,0.8); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                                <div style="width: 0; height: 0; border-left: 20px solid white; border-top: 12px solid transparent; border-bottom: 12px solid transparent; margin-left: 4px;"></div>
                            </div>
                        </a>
                    </div>
                    <p class="small" style="text-align: center; margin-top: 15px; color: var(--text-light);">
                        Introduction to Flows (starts at Election Problem) <span style="color: var(--accent);">(click to open)</span>
                    </p>
                </section>
            </section>

            <!-- ===== SECTION 4: SAT, CSP, and LPs ===== -->
            <section>
                <section class="section-title">
                    <h1>SAT, CSP, and LPs</h1>
                </section>

                <section>
                    <h2></h2>
                </section>
            </section>

            <!-- ===== SECTION 5: Reducing to SAT ===== -->
            <section>
                <section class="section-title">
                    <h1>Reducing to SAT</h1>
                </section>

                <section>
                    <h2></h2>
                </section>
            </section>

            <!-- ===== SECTION 6: Reducing from SAT ===== -->
            <section>
                <section class="section-title">
                    <h1>Reducing from SAT</h1>
                </section>

                <!-- Independent Set Introduction Slide -->
                <section>
                    <h2>The Independent Set Problem</h2>
                    <div class="definition-box">
                        <strong>Independent Set:</strong> Given a graph $G = (V, E)$ and a budget $k$, find a set $S \subseteq V$ of $k$ vertices such that no two vertices in $S$ are adjacent.
                    </div>

                    <div style="display: flex; gap: 30px; margin-top: 20px; align-items: flex-start;">
                        <div style="flex: 1;">
                            <svg width="320" height="240" style="background: white; border: 1px solid #ccc;">
                                <!-- Example graph -->
                                <!-- Vertices -->
                                <circle cx="160" cy="40" r="24" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="160" y="46" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">a</text>

                                <circle cx="60" cy="120" r="24" fill="#b8e6c1" stroke="#222" stroke-width="2"/>
                                <text x="60" y="126" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">b</text>

                                <circle cx="260" cy="120" r="24" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="260" y="126" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">c</text>

                                <circle cx="100" cy="200" r="24" fill="#b8e6c1" stroke="#222" stroke-width="2"/>
                                <text x="100" y="206" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">d</text>

                                <circle cx="220" cy="200" r="24" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="220" y="206" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">e</text>

                                <!-- Edges: a-b, a-c, c-e, d-e, b-c (no b-d edge so {b,d} is independent) -->
                                <line x1="160" y1="64" x2="60" y2="96" stroke="#222" stroke-width="2"/>
                                <line x1="160" y1="64" x2="260" y2="96" stroke="#222" stroke-width="2"/>
                                <line x1="260" y1="144" x2="220" y2="176" stroke="#222" stroke-width="2"/>
                                <line x1="100" y1="200" x2="220" y2="200" stroke="#222" stroke-width="2"/>
                                <line x1="60" y1="120" x2="260" y2="120" stroke="#222" stroke-width="2"/>
                            </svg>
                        </div>
                        <div style="flex: 1;">
                            <div class="theorem-box" style="margin-bottom: 15px;">
                                <strong>Example:</strong> With budget $k = 2$, the vertices $\{b, d\}$ form an independent set (shown in green).
                            </div>
                            <ul style="font-size: 0.9em;">
                                <li>$b$ and $d$ are <strong>not adjacent</strong> to each other</li>
                                <li>We cannot add $a$, $c$, or $e$ without creating an edge within our set</li>
                                <li>This is a <strong>maximum</strong> independent set for this graph</li>
                            </ul>
                            <div class="success-box" style="margin-top: 15px;">
                                <strong>Goal:</strong> We will reduce 3SAT to Independent Set, proving that Independent Set is NP-hard.
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Variable Gadget Slide -->
                <section>
                    <h2>The Variable Gadget</h2>
                    <div class="definition-box" style="margin-bottom: 20px;">
                        <strong>Question:</strong> We need a <em>variable gadget</em> &mdash; something that tells us whether a variable is set to TRUE or FALSE. How do we encode this using Independent Set?
                    </div>

                    <div class="fragment" data-fragment-index="1">
                        <div class="theorem-box">
                            <strong>Answer:</strong> For each variable $x$, create two vertices: $x$ and $\bar{x}$. Connect them with an edge. Any independent set can pick <strong>at most one</strong> of these!
                        </div>

                        <div style="display: flex; justify-content: center; margin-top: 20px;">
                            <svg id="variable-gadget-svg" width="700" height="200" style="background: white; border: 1px solid #ccc;">
                                <!-- Variable w -->
                                <circle cx="80" cy="80" r="22" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="80" y="86" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">w</text>
                                <circle cx="80" cy="160" r="22" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="80" y="166" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">w̄</text>
                                <line x1="80" y1="102" x2="80" y2="138" stroke="#222" stroke-width="2"/>

                                <!-- Variable x -->
                                <circle cx="240" cy="80" r="22" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="240" y="86" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">x</text>
                                <circle cx="240" cy="160" r="22" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="240" y="166" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">x̄</text>
                                <line x1="240" y1="102" x2="240" y2="138" stroke="#222" stroke-width="2"/>

                                <!-- Variable y -->
                                <circle cx="400" cy="80" r="22" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="400" y="86" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">y</text>
                                <circle cx="400" cy="160" r="22" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="400" y="166" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">ȳ</text>
                                <line x1="400" y1="102" x2="400" y2="138" stroke="#222" stroke-width="2"/>

                                <!-- Variable z -->
                                <circle cx="560" cy="80" r="22" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="560" y="86" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">z</text>
                                <circle cx="560" cy="160" r="22" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="560" y="166" text-anchor="middle" font-family="EB Garamond" font-size="18" fill="#222">z̄</text>
                                <line x1="560" y1="102" x2="560" y2="138" stroke="#222" stroke-width="2"/>

                                <!-- Labels -->
                                <text x="640" y="85" font-family="Heliotrope" font-size="12" fill="#666">TRUE</text>
                                <text x="640" y="165" font-family="Heliotrope" font-size="12" fill="#666">FALSE</text>
                            </svg>
                        </div>
                        <p style="text-align: center; font-size: 0.85em; color: #666; margin-top: 10px;">
                            Picking $x$ = "variable is TRUE" &nbsp;|&nbsp; Picking $\bar{x}$ = "variable is FALSE"
                        </p>
                    </div>
                </section>

                <!-- Clause Gadget Slide -->
                <section>
                    <h2>The Clause Gadget</h2>
                    <div class="definition-box" style="margin-bottom: 20px;">
                        <strong>Question:</strong> We need a <em>clause gadget</em> &mdash; something that tells us which literal in a clause was satisfied by the assignment. How do we encode this using Independent Set?
                    </div>

                    <div class="fragment" data-fragment-index="1">
                        <div class="theorem-box">
                            <strong>Answer:</strong> For each clause, create a <strong>triangle</strong> connecting its three literals. Any independent set can pick <strong>at most one</strong> vertex from a triangle!
                        </div>

                        <div style="display: flex; justify-content: center; margin-top: 20px;">
                            <svg id="clause-gadget-svg" width="500" height="280" style="background: white; border: 1px solid #ccc;">
                                <!-- Triangle for clause (x, w-bar, z) -->
                                <polygon points="250,50 100,220 400,220" fill="none" stroke="#222" stroke-width="2"/>

                                <!-- Vertex x -->
                                <circle cx="250" cy="50" r="26" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="250" y="56" text-anchor="middle" font-family="EB Garamond" font-size="20" fill="#222">x</text>

                                <!-- Vertex w-bar -->
                                <circle cx="100" cy="220" r="26" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="100" y="226" text-anchor="middle" font-family="EB Garamond" font-size="20" fill="#222">w̄</text>

                                <!-- Vertex z -->
                                <circle cx="400" cy="220" r="26" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="400" y="226" text-anchor="middle" font-family="EB Garamond" font-size="20" fill="#222">z</text>

                                <!-- Clause label -->
                                <text x="250" y="265" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#666">
                                    Clause: (x ∨ w̄ ∨ z)
                                </text>
                            </svg>
                        </div>
                        <p style="text-align: center; font-size: 0.85em; color: #666; margin-top: 10px;">
                            We can pick <strong>exactly one</strong> literal from each clause &rarr; that's the one that satisfies it!
                        </p>
                    </div>
                </section>

                <!-- Consistency Slide -->
                <section>
                    <h2>Enforcing Consistency</h2>
                    <div class="definition-box" style="margin-bottom: 20px;">
                        <strong>Question:</strong> If a clause claims it is satisfied because $x$ is TRUE, we should not be allowed to set $x$ to FALSE elsewhere. How do we enforce <em>consistency</em>?
                    </div>

                    <div class="fragment" data-fragment-index="1">
                        <div class="theorem-box">
                            <strong>Answer:</strong> Connect each literal vertex in a clause triangle to its <strong>negation</strong> in the variable gadget!
                        </div>

                        <div style="display: flex; justify-content: center; margin-top: 15px;">
                            <svg id="consistency-svg" width="750" height="340" style="background: white; border: 1px solid #ccc;">
                                <!-- Variable gadgets at top -->
                                <!-- Variable w -->
                                <circle cx="100" cy="50" r="20" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="100" y="56" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">w</text>
                                <circle cx="100" cy="110" r="20" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="100" y="116" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">w̄</text>
                                <line x1="100" y1="70" x2="100" y2="90" stroke="#222" stroke-width="2"/>

                                <!-- Variable x -->
                                <circle cx="280" cy="50" r="20" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="280" y="56" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">x</text>
                                <circle cx="280" cy="110" r="20" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="280" y="116" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">x̄</text>
                                <line x1="280" y1="70" x2="280" y2="90" stroke="#222" stroke-width="2"/>

                                <!-- Variable y -->
                                <circle cx="460" cy="50" r="20" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="460" y="56" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">y</text>
                                <circle cx="460" cy="110" r="20" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="460" y="116" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">ȳ</text>
                                <line x1="460" y1="70" x2="460" y2="90" stroke="#222" stroke-width="2"/>

                                <!-- Variable z -->
                                <circle cx="640" cy="50" r="20" fill="#a8d4f0" stroke="#222" stroke-width="2"/>
                                <text x="640" y="56" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">z</text>
                                <circle cx="640" cy="110" r="20" fill="#f5c4c0" stroke="#222" stroke-width="2"/>
                                <text x="640" y="116" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">z̄</text>
                                <line x1="640" y1="70" x2="640" y2="90" stroke="#222" stroke-width="2"/>

                                <!-- Label for variable gadgets -->
                                <text x="375" y="20" text-anchor="middle" font-family="Heliotrope" font-size="13" fill="#666">Variable Gadgets</text>

                                <!-- Clause triangle at bottom -->
                                <!-- Triangle edges -->
                                <line x1="375" y1="210" x2="200" y2="300" stroke="#222" stroke-width="2"/>
                                <line x1="375" y1="210" x2="550" y2="300" stroke="#222" stroke-width="2"/>
                                <line x1="200" y1="300" x2="550" y2="300" stroke="#222" stroke-width="2"/>

                                <!-- Vertex x in clause -->
                                <circle cx="375" cy="210" r="22" fill="#b8e6c1" stroke="#222" stroke-width="2"/>
                                <text x="375" y="216" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">x</text>

                                <!-- Vertex w-bar in clause -->
                                <circle cx="200" cy="300" r="22" fill="#b8e6c1" stroke="#222" stroke-width="2"/>
                                <text x="200" y="306" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">w̄</text>

                                <!-- Vertex z in clause -->
                                <circle cx="550" cy="300" r="22" fill="#b8e6c1" stroke="#222" stroke-width="2"/>
                                <text x="550" y="306" text-anchor="middle" font-family="EB Garamond" font-size="16" fill="#222">z</text>

                                <!-- Clause label -->
                                <text x="375" y="335" text-anchor="middle" font-family="Heliotrope" font-size="13" fill="#666">Clause: (x ∨ w̄ ∨ z)</text>

                                <!-- Consistency edges (dashed, red) -->
                                <!-- x in clause to x-bar in variable gadget -->
                                <line x1="375" y1="188" x2="280" y2="130" stroke="#c44" stroke-width="2" stroke-dasharray="5,3"/>

                                <!-- w-bar in clause to w in variable gadget -->
                                <line x1="200" y1="278" x2="100" y2="70" stroke="#c44" stroke-width="2" stroke-dasharray="5,3"/>

                                <!-- z in clause to z-bar in variable gadget -->
                                <line x1="550" y1="278" x2="640" y2="130" stroke="#c44" stroke-width="2" stroke-dasharray="5,3"/>

                                <!-- Legend -->
                                <line x1="20" y1="160" x2="50" y2="160" stroke="#c44" stroke-width="2" stroke-dasharray="5,3"/>
                                <text x="55" y="164" font-family="Heliotrope" font-size="11" fill="#666">Consistency edges</text>
                            </svg>
                        </div>
                        <p style="text-align: center; font-size: 0.85em; color: #666; margin-top: 8px;">
                            If we pick $x$ in the clause, we <strong>cannot</strong> pick $\bar{x}$ in the variable gadget (and vice versa)!
                        </p>
                    </div>
                </section>

                <!-- Putting It Together Slide -->
                <section>
                    <h2>The Complete Reduction</h2>
                    <div class="theorem-box">
                        <strong>3SAT $\leq_P$ Independent Set:</strong> Given a 3CNF formula $\Phi$ with $n$ variables and $k$ clauses:
                        <ul style="margin-top: 8px; margin-bottom: 0;">
                            <li>Create variable gadgets ($2n$ vertices) and clause triangles ($3k$ vertices)</li>
                            <li>Add consistency edges between clause literals and their negations in variable gadgets</li>
                            <li>$\Phi$ is satisfiable $\Leftrightarrow$ $G$ has an independent set of size $n + k$</li>
                        </ul>
                    </div>

                    <div style="display: flex; gap: 20px; margin-top: 15px;">
                        <div class="success-box" style="flex: 1;">
                            <strong>$\Rightarrow$</strong> If $\Phi$ is satisfiable:
                            <ul style="margin: 5px 0 0 0; font-size: 0.9em;">
                                <li>Pick one literal per variable gadget (n vertices)</li>
                                <li>Pick one true literal per clause (k vertices)</li>
                                <li>Consistency edges don't conflict!</li>
                            </ul>
                        </div>
                        <div class="success-box" style="flex: 1;">
                            <strong>$\Leftarrow$</strong> If $G$ has IS of size $n + k$:
                            <ul style="margin: 5px 0 0 0; font-size: 0.9em;">
                                <li>One vertex per variable gadget (n total)</li>
                                <li>One vertex per clause triangle (k total)</li>
                                <li>Consistency ensures valid assignment!</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Interactive SAT to Independent Set Demo -->
                <section>
                    <h2>Interactive: SAT to Independent Set</h2>
                    <div class="demo-container" style="max-width: 95%; overflow: hidden; box-sizing: border-box;">
                        <div class="demo-header">
                            <span class="demo-title">Build the Reduction Graph</span>
                            <div class="demo-controls">
                                <input type="text" id="sat-formula-input" placeholder="(x,y,z)(~x,w,~z)" style="width: 220px; font-family: monospace;">
                                <button class="btn btn-primary" onclick="buildSATGraph()">Build Graph</button>
                                <button class="btn" onclick="loadExampleFormula()">Example</button>
                                <button class="btn btn-success" onclick="validateSATSelection()">Validate IS</button>
                                <button class="btn btn-secondary" onclick="clearSATDemo()">Clear</button>
                            </div>
                        </div>
                        <p style="font-size: 0.7em; color: #666; margin: 3px 0;">
                            <strong>Format:</strong> <code>(x,y,z)(~x,w,~z)</code> = $(x \vee y \vee z) \wedge (\bar{x} \vee w \vee \bar{z})$.
                            <strong>Click vertices</strong> to select/deselect for your independent set.
                        </p>
                        <div class="demo-canvas" style="display: flex; min-height: 360px; overflow-x: auto;">
                            <svg id="sat-to-is-svg" width="100%" height="360" style="flex: 1; min-width: 650px;"></svg>
                        </div>
                        <div class="demo-output" id="sat-demo-output" style="font-size: 0.8em;">
                            Enter a 3CNF formula above and click "Build Graph" to see the reduction.
                        </div>
                    </div>
                </section>
            </section>

            <!-- ===== SECTION 7: PSPACE Hardness ===== -->
            <section>
                <section class="section-title">
                    <h1>PSPACE Hardness</h1>
                </section>

                <section>
                    <h2></h2>
                </section>
            </section>

        </div>
    </div>

    <!-- RevealJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <!-- KaTeX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            progress: true,
            center: false,
            transition: 'none',
            width: 1100,
            height: 700,
            margin: 0.04
        });

        // Render math
        function renderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '\\[', right: '\\]', display: true},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError: false
            });
        }

        Reveal.on('ready', renderMath);
        Reveal.on('slidechanged', renderMath);

        // ========================================
        // Flow Network Interactive Demo
        // ========================================

        const flowNetwork = {
            edges: {
                's-v1': { flow: 0, capacity: 20, from: 's', to: 'v1' },
                's-v3': { flow: 0, capacity: 10, from: 's', to: 'v3' },
                'v1-v2': { flow: 0, capacity: 5, from: 'v1', to: 'v2' },
                'v1-v3': { flow: 0, capacity: 10, from: 'v1', to: 'v3' },
                'v1-v4': { flow: 0, capacity: 15, from: 'v1', to: 'v4' },
                'v3-v4': { flow: 0, capacity: 10, from: 'v3', to: 'v4' },
                'v4-v2': { flow: 0, capacity: 10, from: 'v4', to: 'v2' },
                'v2-t': { flow: 0, capacity: 15, from: 'v2', to: 't' },
                'v4-t': { flow: 0, capacity: 20, from: 'v4', to: 't' }
            },
            nodes: ['s', 'v1', 'v2', 'v3', 'v4', 't']
        };

        function adjustFlow(edgeId, delta) {
            const edge = flowNetwork.edges[edgeId];
            const newFlow = edge.flow + delta;

            // Enforce capacity constraint (0 <= flow <= capacity)
            if (newFlow < 0 || newFlow > edge.capacity) {
                return;
            }

            edge.flow = newFlow;
            updateFlowDisplay(edgeId);
            validateAndComment();
        }

        function updateFlowDisplay(edgeId) {
            const edge = flowNetwork.edges[edgeId];
            const flowEl = document.getElementById('flow-' + edgeId);
            if (flowEl) {
                flowEl.textContent = edge.flow;
            }
        }

        function resetFlows() {
            for (const edgeId in flowNetwork.edges) {
                flowNetwork.edges[edgeId].flow = 0;
                updateFlowDisplay(edgeId);
                // Reset edge color
                const edgeEl = document.getElementById('edge-' + edgeId);
                if (edgeEl) edgeEl.setAttribute('stroke', '#555');
            }
            // Reset node colors
            const allNodes = ['s', 'v1', 'v2', 'v3', 'v4', 't'];
            for (const node of allNodes) {
                const nodeEl = document.getElementById('node-' + node);
                if (nodeEl) nodeEl.setAttribute('fill', 'white');
                // Reset net flow display
                const netflowEl = document.getElementById('netflow-' + node);
                if (netflowEl) netflowEl.textContent = '0';
            }
            document.getElementById('flow-commentary').innerHTML =
                "Here's a flow network. What is the maximum flow that you can drive through it?";
        }

        function getFlowIn(node) {
            let total = 0;
            for (const edgeId in flowNetwork.edges) {
                const edge = flowNetwork.edges[edgeId];
                if (edge.to === node) {
                    total += edge.flow;
                }
            }
            return total;
        }

        function getFlowOut(node) {
            let total = 0;
            for (const edgeId in flowNetwork.edges) {
                const edge = flowNetwork.edges[edgeId];
                if (edge.from === node) {
                    total += edge.flow;
                }
            }
            return total;
        }

        function updateNetFlowDisplays() {
            // Update source s: show outgoing flow
            const sOut = getFlowOut('s');
            const sEl = document.getElementById('netflow-s');
            if (sEl) sEl.textContent = sOut;

            // Update sink t: show incoming flow
            const tIn = getFlowIn('t');
            const tEl = document.getElementById('netflow-t');
            if (tEl) tEl.textContent = tIn;

            // Update intermediate nodes: show net flow (in - out)
            const intermediateNodes = ['v1', 'v2', 'v3', 'v4'];
            for (const node of intermediateNodes) {
                const flowIn = getFlowIn(node);
                const flowOut = getFlowOut(node);
                const netFlow = flowIn - flowOut;
                const el = document.getElementById('netflow-' + node);
                if (el) {
                    if (netFlow === 0) {
                        el.textContent = '0';
                    } else if (netFlow > 0) {
                        el.textContent = '+' + netFlow;
                    } else {
                        el.textContent = netFlow;
                    }
                }
            }
        }

        function validateAndComment() {
            const commentary = document.getElementById('flow-commentary');
            const conservationViolations = [];
            const capacityViolations = [];

            // Update net flow displays
            updateNetFlowDisplays();

            // Reset all node colors
            const allNodes = ['s', 'v1', 'v2', 'v3', 'v4', 't'];
            for (const node of allNodes) {
                const nodeEl = document.getElementById('node-' + node);
                if (nodeEl) nodeEl.setAttribute('fill', 'white');
            }

            // Reset all edge colors
            for (const edgeId in flowNetwork.edges) {
                const edgeEl = document.getElementById('edge-' + edgeId);
                if (edgeEl) edgeEl.setAttribute('stroke', '#555');
            }

            // Check capacity constraints on all edges
            for (const edgeId in flowNetwork.edges) {
                const edge = flowNetwork.edges[edgeId];
                if (edge.flow < 0 || edge.flow > edge.capacity) {
                    capacityViolations.push(edgeId);
                    const edgeEl = document.getElementById('edge-' + edgeId);
                    if (edgeEl) edgeEl.setAttribute('stroke', '#E97451'); // Light BurntOrange
                }
            }

            // Check conservation at intermediate nodes (not s or t)
            const intermediateNodes = ['v1', 'v2', 'v3', 'v4'];
            for (const node of intermediateNodes) {
                const flowIn = getFlowIn(node);
                const flowOut = getFlowOut(node);
                if (flowIn !== flowOut) {
                    conservationViolations.push({
                        node: node,
                        flowIn: flowIn,
                        flowOut: flowOut
                    });
                    // Highlight the node based on violation type
                    const nodeEl = document.getElementById('node-' + node);
                    if (nodeEl) {
                        if (flowIn > flowOut) {
                            // Flow is pooling at this vertex - blue
                            nodeEl.setAttribute('fill', '#A0C4E8'); // Light blue
                        } else {
                            // Flow is leaking from this vertex - red
                            nodeEl.setAttribute('fill', '#F0A0A0'); // Light IndianRed
                        }
                    }
                }
            }

            // Generate commentary
            if (capacityViolations.length > 0) {
                const edgeLabel = capacityViolations[0].replace('-', ' → ');
                commentary.innerHTML =
                    `<span style="color: #E97451;"><strong>Capacity violated on edge ${edgeLabel}:</strong></span> ` +
                    `Flow must satisfy 0 ≤ f(e) ≤ c(e).`;
            } else if (conservationViolations.length > 0) {
                const v = conservationViolations[0];
                const nodeLabel = v.node.replace('v', 'v<sub>') + '</sub>';
                const violationType = v.flowIn > v.flowOut ? 'pooling' : 'leaking';
                const color = v.flowIn > v.flowOut ? '#4A90D9' : '#CD5C5C';
                commentary.innerHTML =
                    `<span style="color: ${color};"><strong>Conservation violated at ${nodeLabel}:</strong></span> ` +
                    `Flow in = ${v.flowIn}, Flow out = ${v.flowOut} (${violationType}). ` +
                    `<em>These must be equal!</em>`;
            } else {
                // Flow is valid, compute total value
                const flowValue = getFlowOut('s') - getFlowIn('s');
                if (flowValue === 0) {
                    commentary.innerHTML =
                        "Here's a flow network. What is the maximum flow that you can drive through it?";
                } else {
                    commentary.innerHTML =
                        `<span style="color: #059669;"><strong>Valid flow!</strong></span> ` +
                        `Total flow value: <strong>|f| = ${flowValue}</strong>`;
                }
            }
        }

        // ========================================
        // IPL Elimination Interactive Demo
        // ========================================

        // IPL Team data with colors
        const iplTeamInfo = {
            'MI': { name: 'Mumbai Indians', color: '#004BA0', textColor: '#FFD700' },
            'CSK': { name: 'Chennai Super Kings', color: '#FFCB05', textColor: '#0066B3' },
            'KKR': { name: 'Kolkata Knight Riders', color: '#3A225D', textColor: '#FFD700' }
        };

        // Current state (mutable)
        let iplState = {
            teams: {},  // { MI: { wins: 10 }, CSK: { wins: 11 }, ... }
            matches: [], // [ { id: 1, team1: 'MI', team2: 'CSK', winner: null }, ... ]
            targetX: 11
        };

        // Default instance
        const defaultInstance = {
            teams: { 'MI': 10, 'CSK': 11, 'KKR': 9 },
            matches: [
                { team1: 'MI', team2: 'CSK' },
                { team1: 'MI', team2: 'KKR' },
                { team1: 'CSK', team2: 'KKR' }
            ],
            targetX: 11
        };

        function initIPLDemo() {
            loadIPLInstance(defaultInstance);
        }

        function loadIPLInstance(instance) {
            // Set up teams
            iplState.teams = {};
            for (const team in instance.teams) {
                iplState.teams[team] = {
                    ...iplTeamInfo[team],
                    wins: instance.teams[team]
                };
            }
            // Set up matches with IDs
            iplState.matches = instance.matches.map((m, idx) => ({
                id: idx + 1,
                team1: m.team1,
                team2: m.team2,
                winner: null
            }));
            iplState.targetX = instance.targetX;

            renderIPLDemo();
        }

        function randomIPLInstance() {
            const teams = ['MI', 'CSK', 'KKR'];
            const maxMatches = 7; // Cap total matches to avoid overflow

            // Generate matches first (1-3 per pair, but cap total)
            let matches = [];
            const pairsNeeded = [];
            for (let i = 0; i < teams.length; i++) {
                for (let j = i + 1; j < teams.length; j++) {
                    const numGames = 1 + Math.floor(Math.random() * 3);
                    for (let k = 0; k < numGames; k++) {
                        pairsNeeded.push({ team1: teams[i], team2: teams[j] });
                    }
                }
            }
            // Shuffle and cap at maxMatches
            pairsNeeded.sort(() => Math.random() - 0.5);
            matches = pairsNeeded.slice(0, maxMatches);

            // Ensure at least 1 match per pair for variety
            const hasPair = {};
            matches.forEach(m => {
                const key = [m.team1, m.team2].sort().join('-');
                hasPair[key] = true;
            });
            for (let i = 0; i < teams.length; i++) {
                for (let j = i + 1; j < teams.length; j++) {
                    const key = [teams[i], teams[j]].sort().join('-');
                    if (!hasPair[key] && matches.length < maxMatches) {
                        matches.push({ team1: teams[i], team2: teams[j] });
                        hasPair[key] = true;
                    }
                }
            }

            const totalGames = matches.length;

            // Generate wins and target X to create a subtle instance
            // Strategy: set target X first, then set wins such that:
            // - No team exceeds X initially
            // - Total slack is close to (but not less than) total games for interesting puzzles
            const targetX = 10 + Math.floor(Math.random() * 4); // X between 10-13

            const wins = {};
            // Give each team wins between (X-4) and X, with some randomness
            teams.forEach(t => {
                const minWins = Math.max(6, targetX - 4);
                const maxWins = targetX; // Never exceed X initially
                wins[t] = minWins + Math.floor(Math.random() * (maxWins - minWins + 1));
            });

            // Calculate initial slack
            let totalSlack = teams.reduce((sum, t) => sum + (targetX - wins[t]), 0);

            // Adjust to make it subtle: slack should be close to totalGames
            // If slack is too high, increase some wins
            while (totalSlack > totalGames + 2) {
                const t = teams[Math.floor(Math.random() * teams.length)];
                if (wins[t] < targetX) {
                    wins[t]++;
                    totalSlack--;
                }
            }

            // If slack equals games exactly, randomly make it slightly tighter or looser
            // to create variety (some solvable, some not)
            if (Math.random() < 0.4 && totalSlack > totalGames) {
                // Make it tighter (possibly unsolvable)
                const t = teams[Math.floor(Math.random() * teams.length)];
                if (wins[t] < targetX) {
                    wins[t]++;
                }
            }

            loadIPLInstance({ teams: wins, matches, targetX });
        }

        function renderIPLDemo() {
            renderStandings();
            renderMatches();
            updateIPLAnalysis();

            // Update target display
            const targetEl = document.getElementById('target-x');
            if (targetEl) targetEl.textContent = iplState.targetX;
        }

        function renderStandings() {
            const container = document.getElementById('ipl-standings-cards');
            if (!container) return;

            // Calculate current wins including match results
            const currentWins = {};
            for (const team in iplState.teams) {
                currentWins[team] = iplState.teams[team].wins;
            }

            // Add wins from decided matches
            iplState.matches.forEach(m => {
                if (m.winner) {
                    currentWins[m.winner] = (currentWins[m.winner] || 0) + 1;
                }
            });

            // Sort teams by wins
            const sortedTeams = Object.keys(iplState.teams).sort((a, b) => currentWins[b] - currentWins[a]);
            const X = iplState.targetX;

            let html = '';
            sortedTeams.forEach((team, idx) => {
                const t = iplState.teams[team];
                const wins = currentWins[team];
                const exceeds = wins > X;
                const atLimit = wins === X;
                const bgColor = exceeds ? '#ffebee' : (atLimit ? '#fff8e1' : 'white');
                const borderColor = exceeds ? '#ef5350' : (atLimit ? '#ffb300' : '#ddd');

                html += `
                    <div style="display: flex; align-items: center; padding: 8px 12px; background: ${bgColor}; border-radius: 6px; border: 2px solid ${borderColor};">
                        <span style="display: inline-block; width: 14px; height: 14px; background: ${t.color}; border-radius: 3px; margin-right: 8px;"></span>
                        <span style="flex: 1; font-weight: 500;">${team}</span>
                        <span style="font-weight: 600; font-size: 1.1em; color: ${exceeds ? '#c62828' : '#333'};">${wins}</span>
                        ${exceeds ? '<span style="color: #c62828; font-size: 0.8em; margin-left: 4px;">⚠️</span>' : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function renderMatches() {
            const container = document.getElementById('ipl-matches');
            if (!container) return;

            let html = '';
            iplState.matches.forEach(match => {
                const t1 = iplState.teams[match.team1];
                const t2 = iplState.teams[match.team2];
                const winner = match.winner;

                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: #f8f8f8; border-radius: 6px;">
                        <button onclick="assignWinner(${match.id}, '${match.team1}')"
                                style="flex: 1; padding: 8px; border: 2px solid ${winner === match.team1 ? t1.color : '#ddd'};
                                       background: ${winner === match.team1 ? t1.color : 'white'};
                                       color: ${winner === match.team1 ? t1.textColor : '#333'};
                                       border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9em;
                                       transition: all 0.2s;">
                            ${match.team1} ${winner === match.team1 ? '✓' : ''}
                        </button>
                        <span style="color: #888; font-size: 0.85em;">vs</span>
                        <button onclick="assignWinner(${match.id}, '${match.team2}')"
                                style="flex: 1; padding: 8px; border: 2px solid ${winner === match.team2 ? t2.color : '#ddd'};
                                       background: ${winner === match.team2 ? t2.color : 'white'};
                                       color: ${winner === match.team2 ? t2.textColor : '#333'};
                                       border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.9em;
                                       transition: all 0.2s;">
                            ${match.team2} ${winner === match.team2 ? '✓' : ''}
                        </button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function assignWinner(matchId, winner) {
            const match = iplState.matches.find(m => m.id === matchId);
            if (match) {
                // Toggle: if already selected, deselect
                match.winner = match.winner === winner ? null : winner;
                renderIPLDemo();
            }
        }

        function updateIPLAnalysis() {
            const commentary = document.getElementById('ipl-commentary');
            if (!commentary) return;

            const X = iplState.targetX;

            // Calculate projected wins
            const projectedWins = {};
            for (const team in iplState.teams) {
                projectedWins[team] = iplState.teams[team].wins;
            }
            iplState.matches.forEach(m => {
                if (m.winner) {
                    projectedWins[m.winner]++;
                }
            });

            // Count unassigned matches
            const unassigned = iplState.matches.filter(m => !m.winner).length;
            const totalMatches = iplState.matches.length;

            // Check if any team exceeds target
            let exceeds = false;
            let exceedingTeam = null;
            for (const team in projectedWins) {
                if (projectedWins[team] > X) {
                    exceeds = true;
                    exceedingTeam = team;
                    break;
                }
            }

            // Calculate slack for each team
            const slacks = {};
            for (const team in projectedWins) {
                slacks[team] = Math.max(0, X - projectedWins[team]);
            }
            const totalSlack = Object.values(slacks).reduce((a, b) => a + b, 0);

            if (exceeds) {
                commentary.innerHTML = `
                    <span style="color: #DC143C;"><strong>❌ Constraint Violated!</strong></span>
                    ${exceedingTeam} has ${projectedWins[exceedingTeam]} wins, exceeding target X = ${X}.
                `;
            } else if (unassigned === 0) {
                commentary.innerHTML = `
                    <span style="color: #059669;"><strong>🎉 Congratulations!</strong></span>
                    You found a valid assignment! All ${totalMatches} matches assigned with every team ≤ ${X} wins.
                `;
            } else {
                commentary.innerHTML = `
                    ${unassigned}/${totalMatches} matches remaining. Assign winners to all matches.
                `;
            }
        }

        function declareHopeless() {
            const commentary = document.getElementById('ipl-commentary');
            if (!commentary) return;

            const X = iplState.targetX;

            // Calculate current wins
            const currentWins = {};
            for (const team in iplState.teams) {
                currentWins[team] = iplState.teams[team].wins;
            }
            iplState.matches.forEach(m => {
                if (m.winner) {
                    currentWins[m.winner]++;
                }
            });

            // Check if it's actually hopeless by computing max flow
            // Simple heuristic: total slack vs total unassigned games
            const unassigned = iplState.matches.filter(m => !m.winner).length;
            const slacks = {};
            for (const team in currentWins) {
                slacks[team] = Math.max(0, X - currentWins[team]);
            }
            const totalSlack = Object.values(slacks).reduce((a, b) => a + b, 0);

            // This is a simplified check - actual elimination may require proper max flow
            // For this demo, we use the heuristic that if total slack < unassigned, it's impossible
            if (totalSlack < unassigned) {
                commentary.innerHTML = `
                    <span style="color: #059669;"><strong>✓ Correct!</strong></span>
                    This instance is indeed hopeless. Total slack (${totalSlack}) < remaining games (${unassigned}).
                `;
            } else {
                commentary.innerHTML = `
                    <span style="color: #f59e0b;"><strong>🤔 Are you sure?</strong></span>
                    There might still be a valid assignment. Keep trying!
                `;
            }
        }

        function resetIPLDemo() {
            loadIPLInstance(defaultInstance);
        }

        // ========================================
        // Flow Network Builder (Step-by-Step)
        // ========================================

        const flowBuilderData = {
            teams: ['MI', 'CSK', 'KKR'],
            teamInfo: {
                'MI': { color: '#004BA0', textColor: '#FFD700', wins: 10 },
                'CSK': { color: '#FFCB05', textColor: '#0066B3', wins: 11 },
                'KKR': { color: '#3A225D', textColor: '#FFD700', wins: 9 }
            },
            matches: [
                { team1: 'MI', team2: 'CSK', games: 1 },
                { team1: 'MI', team2: 'KKR', games: 1 },
                { team1: 'CSK', team2: 'KKR', games: 1 }
            ],
            targetX: 11,
            currentStep: 0,
            flowResult: null // Will store computed flow
        };

        // Positions for SVG elements
        const fbPositions = {
            s: { x: 50, y: 145 },
            t: { x: 700, y: 145 },
            teams: {
                'MI': { x: 530, y: 55 },
                'CSK': { x: 530, y: 145 },
                'KKR': { x: 530, y: 235 }
            },
            pairs: {
                'MI-CSK': { x: 250, y: 55 },
                'MI-KKR': { x: 250, y: 145 },
                'CSK-KKR': { x: 250, y: 235 }
            }
        };

        // Read inputs and load into flowBuilderData
        function readFlowBuilderInputs() {
            flowBuilderData.teamInfo['MI'].wins = parseInt(document.getElementById('fb-input-wins-mi').value) || 0;
            flowBuilderData.teamInfo['CSK'].wins = parseInt(document.getElementById('fb-input-wins-csk').value) || 0;
            flowBuilderData.teamInfo['KKR'].wins = parseInt(document.getElementById('fb-input-wins-kkr').value) || 0;

            flowBuilderData.matches[0].games = parseInt(document.getElementById('fb-input-games-mi-csk').value) || 0;
            flowBuilderData.matches[1].games = parseInt(document.getElementById('fb-input-games-mi-kkr').value) || 0;
            flowBuilderData.matches[2].games = parseInt(document.getElementById('fb-input-games-csk-kkr').value) || 0;

            flowBuilderData.targetX = parseInt(document.getElementById('fb-input-target').value) || 0;
        }

        // Generate a random instance
        function randomFlowBuilderInstance() {
            // Random wins between 6 and 12
            const miWins = Math.floor(Math.random() * 7) + 6;
            const cskWins = Math.floor(Math.random() * 7) + 6;
            const kkrWins = Math.floor(Math.random() * 7) + 6;

            // Random remaining games (1-3 each)
            let g1 = Math.floor(Math.random() * 3) + 1;
            let g2 = Math.floor(Math.random() * 3) + 1;
            let g3 = Math.floor(Math.random() * 3) + 1;

            // Target X: at least max of current wins (ensures no instant elimination)
            const maxWins = Math.max(miWins, cskWins, kkrWins);
            // 50% chance of targetX = maxWins (tight), 50% chance of maxWins + 1 (some slack)
            const targetX = maxWins + Math.floor(Math.random() * 2);

            // Set input values
            document.getElementById('fb-input-wins-mi').value = miWins;
            document.getElementById('fb-input-wins-csk').value = cskWins;
            document.getElementById('fb-input-wins-kkr').value = kkrWins;
            document.getElementById('fb-input-games-mi-csk').value = g1;
            document.getElementById('fb-input-games-mi-kkr').value = g2;
            document.getElementById('fb-input-games-csk-kkr').value = g3;
            document.getElementById('fb-input-target').value = targetX;

            // Reset any error message
            const inputPhase = document.getElementById('fb-input-phase');
            const outputDiv = inputPhase.querySelector('.demo-output');
            outputDiv.innerHTML = 'Random instance generated! Click <strong>Build Network →</strong> to visualize.';
        }

        // Compute max flow using Ford-Fulkerson style
        function computeMaxFlow() {
            const X = flowBuilderData.targetX;
            const teams = flowBuilderData.teams;
            const matches = flowBuilderData.matches;

            // Build adjacency with capacities
            // Nodes: 's', 't', 'MI', 'CSK', 'KKR', 'MI-CSK', 'MI-KKR', 'CSK-KKR'
            const nodes = ['s', 't', 'MI', 'CSK', 'KKR', 'MI-CSK', 'MI-KKR', 'CSK-KKR'];
            const capacity = {};
            const flow = {};

            // Initialize
            nodes.forEach(u => {
                capacity[u] = {};
                flow[u] = {};
                nodes.forEach(v => {
                    capacity[u][v] = 0;
                    flow[u][v] = 0;
                });
            });

            // Source to match nodes
            matches.forEach((m, i) => {
                const matchNode = m.team1 + '-' + m.team2;
                capacity['s'][matchNode] = m.games;
            });

            // Match nodes to teams (infinite = large number)
            matches.forEach(m => {
                const matchNode = m.team1 + '-' + m.team2;
                capacity[matchNode][m.team1] = 100;
                capacity[matchNode][m.team2] = 100;
            });

            // Teams to sink
            teams.forEach(t => {
                const slack = X - flowBuilderData.teamInfo[t].wins;
                capacity[t]['t'] = Math.max(0, slack);
            });

            // BFS to find augmenting path
            function bfs() {
                const visited = { 's': true };
                const parent = { 's': null };
                const queue = ['s'];

                while (queue.length > 0) {
                    const u = queue.shift();

                    for (const v of nodes) {
                        if (!visited[v] && capacity[u][v] - flow[u][v] > 0) {
                            visited[v] = true;
                            parent[v] = u;
                            if (v === 't') return parent;
                            queue.push(v);
                        }
                    }
                }
                return null;
            }

            // Ford-Fulkerson
            let maxFlowValue = 0;
            let parent;

            while ((parent = bfs()) !== null) {
                // Find min residual capacity
                let pathFlow = Infinity;
                let v = 't';
                while (v !== 's') {
                    const u = parent[v];
                    pathFlow = Math.min(pathFlow, capacity[u][v] - flow[u][v]);
                    v = u;
                }

                // Update flows
                v = 't';
                while (v !== 's') {
                    const u = parent[v];
                    flow[u][v] += pathFlow;
                    flow[v][u] -= pathFlow;
                    v = u;
                }

                maxFlowValue += pathFlow;
            }

            // Find min-cut (reachable from s in residual graph)
            const reachable = { 's': true };
            const queue = ['s'];
            while (queue.length > 0) {
                const u = queue.shift();
                for (const v of nodes) {
                    if (!reachable[v] && capacity[u][v] - flow[u][v] > 0) {
                        reachable[v] = true;
                        queue.push(v);
                    }
                }
            }

            // Total games
            let totalGames = 0;
            matches.forEach(m => totalGames += m.games);

            return {
                maxFlow: maxFlowValue,
                totalGames: totalGames,
                flow: flow,
                saturated: maxFlowValue >= totalGames,
                reachable: reachable,
                capacity: capacity
            };
        }

        // Check if any team already exceeds target X (instant elimination)
        function checkInstantElimination() {
            const X = flowBuilderData.targetX;
            const violators = [];
            for (const t of flowBuilderData.teams) {
                const wins = flowBuilderData.teamInfo[t].wins;
                if (wins > X) {
                    violators.push({ team: t, wins: wins });
                }
            }
            return violators;
        }

        // Start the flow builder visualization
        function startFlowBuilder() {
            readFlowBuilderInputs();

            // Check for instant elimination (negative slack)
            const violators = checkInstantElimination();
            if (violators.length > 0) {
                // Show error in input phase instead of building network
                const inputPhase = document.getElementById('fb-input-phase');
                const outputDiv = inputPhase.querySelector('.demo-output');
                const violatorList = violators.map(v => `<strong>${v.team}</strong> (${v.wins} wins)`).join(', ');
                outputDiv.innerHTML = `<span style="color: #c62828;"><strong>Instant Elimination!</strong></span> ${violatorList} already exceed${violators.length === 1 ? 's' : ''} target X = <strong>${flowBuilderData.targetX}</strong>. No network needed — the target team is already eliminated.`;
                return;
            }

            flowBuilderData.currentStep = 0;
            flowBuilderData.flowResult = computeMaxFlow();

            document.getElementById('fb-input-phase').style.display = 'none';
            document.getElementById('fb-build-phase').style.display = 'block';

            updateFlowBuilderTable();
            renderFlowBuilderStep();
        }

        function initFlowBuilder() {
            // Show input phase
            const inputPhase = document.getElementById('fb-input-phase');
            const buildPhase = document.getElementById('fb-build-phase');
            if (inputPhase) inputPhase.style.display = 'block';
            if (buildPhase) buildPhase.style.display = 'none';
        }

        function updateFlowBuilderTable() {
            const X = flowBuilderData.targetX;
            document.getElementById('fb-target-x').textContent = X;

            let totalGames = 0;
            flowBuilderData.teams.forEach(t => {
                const wins = flowBuilderData.teamInfo[t].wins;
                const slack = X - wins;
                document.getElementById('fb-wins-' + t.toLowerCase()).textContent = wins;
                document.getElementById('fb-slack-' + t.toLowerCase()).innerHTML = slack >= 0 ? slack : `<span style="color:red">${slack}</span>`;
            });

            flowBuilderData.matches.forEach(m => totalGames += m.games);
            document.getElementById('fb-total-games').textContent = totalGames;
        }

        function renderFlowBuilderStep() {
            const svg = document.getElementById('flow-builder-svg');
            const commentary = document.getElementById('flow-builder-commentary');
            const btn = document.getElementById('flow-next-btn');
            if (!svg || !commentary) return;

            const step = flowBuilderData.currentStep;
            const X = flowBuilderData.targetX;
            const result = flowBuilderData.flowResult;

            let html = `<defs>
                <marker id="arrowhead3" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#555"/>
                </marker>
                <marker id="arrowheadGreen" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#059669"/>
                </marker>
                <marker id="arrowheadRed" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#c62828"/>
                </marker>
            </defs>`;

            const showFlow = step >= 4;
            const f = result ? result.flow : null;
            const reachable = result ? result.reachable : {};
            const saturated = result ? result.saturated : true;

            // Source node (highlight if in cut for non-saturated)
            const sInCut = !saturated && reachable['s'];
            html += `
                <circle cx="${fbPositions.s.x}" cy="${fbPositions.s.y}" r="22" fill="${sInCut && showFlow ? 'rgba(0,150,136,0.3)' : '#a8d4f0'}" stroke="${sInCut && showFlow ? '#009688' : '#222'}" stroke-width="${sInCut && showFlow ? 3 : 2}"/>
                <text x="${fbPositions.s.x}" y="${fbPositions.s.y + 5}" text-anchor="middle" font-size="16" font-weight="600" fill="#222">s</text>
            `;

            // Sink node
            html += `
                <circle cx="${fbPositions.t.x}" cy="${fbPositions.t.y}" r="22" fill="#f0a0a0" stroke="#222" stroke-width="2"/>
                <text x="${fbPositions.t.x}" y="${fbPositions.t.y + 5}" text-anchor="middle" font-size="16" font-weight="600" fill="#222">t</text>
            `;

            // Step 1+: Team nodes and edges to t
            if (step >= 1) {
                flowBuilderData.teams.forEach(t => {
                    const pos = fbPositions.teams[t];
                    const info = flowBuilderData.teamInfo[t];
                    const slack = Math.max(0, X - info.wins);
                    const inCut = !saturated && reachable[t];

                    // Team node (highlight if in min-cut for non-saturated)
                    html += `
                        <circle cx="${pos.x}" cy="${pos.y}" r="26" fill="${inCut && showFlow ? 'rgba(0,150,136,0.3)' : info.color}" stroke="${inCut && showFlow ? '#009688' : '#222'}" stroke-width="${inCut && showFlow ? 3 : 2}"/>
                        <text x="${pos.x}" y="${pos.y + 5}" text-anchor="middle" font-size="13" font-weight="600" fill="${info.textColor}">${t}</text>
                    `;

                    // Edge to t
                    const flowToT = showFlow && f ? Math.max(0, f[t]['t']) : 0;
                    const isCutEdge = showFlow && !saturated && reachable[t] && !reachable['t'];
                    const edgeColor = showFlow ? (isCutEdge ? '#c62828' : '#059669') : '#555';
                    const marker = showFlow ? (isCutEdge ? 'url(#arrowheadRed)' : 'url(#arrowheadGreen)') : 'url(#arrowhead3)';

                    html += `
                        <line x1="${pos.x + 26}" y1="${pos.y}" x2="${fbPositions.t.x - 24}" y2="${fbPositions.t.y}"
                              stroke="${edgeColor}" stroke-width="${showFlow ? 3 : 2}" marker-end="${marker}"/>
                    `;

                    // Capacity/flow label
                    const labelX = pos.x + 75;
                    const labelY = pos.y - 10;
                    if (showFlow) {
                        html += `<text x="${labelX}" y="${labelY}" text-anchor="middle" font-size="11" fill="${edgeColor}" font-weight="600">${flowToT}/${slack}</text>`;
                    } else {
                        html += `<text x="${labelX}" y="${labelY}" text-anchor="middle" font-size="11" fill="#c62828" font-weight="600">${slack}</text>`;
                    }
                });
            }

            // Step 2+: Pairwise match nodes and edges to teams
            if (step >= 2) {
                flowBuilderData.matches.forEach(m => {
                    const key = m.team1 + '-' + m.team2;
                    const pos = fbPositions.pairs[key];
                    const t1Pos = fbPositions.teams[m.team1];
                    const t2Pos = fbPositions.teams[m.team2];
                    const inCut = !saturated && reachable[key];

                    // Match node
                    html += `
                        <circle cx="${pos.x}" cy="${pos.y}" r="26" fill="${inCut && showFlow ? 'rgba(0,150,136,0.3)' : '#f5e6a3'}" stroke="${inCut && showFlow ? '#009688' : '#222'}" stroke-width="${inCut && showFlow ? 3 : 2}"/>
                        <text x="${pos.x}" y="${pos.y - 5}" text-anchor="middle" font-size="11" fill="#222">${m.team1}</text>
                        <text x="${pos.x}" y="${pos.y + 9}" text-anchor="middle" font-size="11" fill="#222">${m.team2}</text>
                    `;

                    // Edges to teams
                    const f1 = showFlow && f ? Math.max(0, f[key][m.team1]) : 0;
                    const f2 = showFlow && f ? Math.max(0, f[key][m.team2]) : 0;

                    // Edge to team1
                    const color1 = showFlow ? '#059669' : '#888';
                    html += `
                        <line x1="${pos.x + 26}" y1="${pos.y - 8}" x2="${t1Pos.x - 28}" y2="${t1Pos.y + 5}"
                              stroke="${color1}" stroke-width="${showFlow ? 2.5 : 1.5}" ${showFlow ? '' : 'stroke-dasharray="4,2"'} marker-end="${showFlow ? 'url(#arrowheadGreen)' : 'url(#arrowhead3)'}"/>
                    `;
                    if (showFlow) {
                        const mx1 = (pos.x + 26 + t1Pos.x - 28) / 2;
                        const my1 = (pos.y - 8 + t1Pos.y + 5) / 2 - 8;
                        html += `<text x="${mx1}" y="${my1}" text-anchor="middle" font-size="10" fill="#059669" font-weight="600">${f1}</text>`;
                    }

                    // Edge to team2
                    const color2 = showFlow ? '#059669' : '#888';
                    html += `
                        <line x1="${pos.x + 26}" y1="${pos.y + 8}" x2="${t2Pos.x - 28}" y2="${t2Pos.y - 5}"
                              stroke="${color2}" stroke-width="${showFlow ? 2.5 : 1.5}" ${showFlow ? '' : 'stroke-dasharray="4,2"'} marker-end="${showFlow ? 'url(#arrowheadGreen)' : 'url(#arrowhead3)'}"/>
                    `;
                    if (showFlow) {
                        const mx2 = (pos.x + 26 + t2Pos.x - 28) / 2;
                        const my2 = (pos.y + 8 + t2Pos.y - 5) / 2 + 12;
                        html += `<text x="${mx2}" y="${my2}" text-anchor="middle" font-size="10" fill="#059669" font-weight="600">${f2}</text>`;
                    }
                });
            }

            // Step 3+: Source edges to pair nodes
            if (step >= 3) {
                flowBuilderData.matches.forEach(m => {
                    const key = m.team1 + '-' + m.team2;
                    const pos = fbPositions.pairs[key];

                    const flowFromS = showFlow && f ? Math.max(0, f['s'][key]) : 0;
                    const isSaturated = flowFromS >= m.games;
                    const edgeColor = showFlow ? (isSaturated ? '#059669' : '#c62828') : '#555';
                    const marker = showFlow ? (isSaturated ? 'url(#arrowheadGreen)' : 'url(#arrowheadRed)') : 'url(#arrowhead3)';

                    html += `
                        <line x1="${fbPositions.s.x + 22}" y1="${fbPositions.s.y}" x2="${pos.x - 28}" y2="${pos.y}"
                              stroke="${edgeColor}" stroke-width="${showFlow ? 3 : 2}" marker-end="${marker}"/>
                    `;

                    // Label
                    const labelX = fbPositions.s.x + 70;
                    const labelY = pos.y - 10;
                    if (showFlow) {
                        html += `<text x="${labelX}" y="${labelY}" text-anchor="middle" font-size="11" fill="${edgeColor}" font-weight="600">${flowFromS}/${m.games}</text>`;
                    } else {
                        html += `<text x="${labelX}" y="${labelY}" text-anchor="middle" font-size="11" fill="#1565c0" font-weight="600">${m.games}</text>`;
                    }
                });
            }

            // Min-cut legend for step 4 if not saturated
            if (step >= 4 && !saturated) {
                html += `
                    <rect x="10" y="10" width="120" height="50" fill="white" stroke="#ddd" rx="4"/>
                    <circle cx="25" cy="25" r="8" fill="rgba(0,150,136,0.3)" stroke="#009688" stroke-width="2"/>
                    <text x="38" y="29" font-size="10" fill="#333">= in S (min-cut)</text>
                    <line x1="18" y1="42" x2="38" y2="42" stroke="#c62828" stroke-width="2"/>
                    <text x="43" y="46" font-size="10" fill="#333">= cut edge</text>
                `;
            }

            svg.innerHTML = html;

            // Update commentary
            const stepMessages = [
                'Step 0: Start with source <strong>s</strong> and sink <strong>t</strong>.',
                'Step 1: Add team nodes. Connect each to <strong>t</strong> with capacity = <span style="color:#c62828">X − wins</span> (slack).',
                'Step 2: Add match nodes for each pair. Connect to both teams with <strong>∞</strong> capacity.',
                'Step 3: Connect <strong>s</strong> to each match node with capacity = <span style="color:#1565c0">number of games</span>.',
                getMaxFlowResult()
            ];
            commentary.innerHTML = stepMessages[step];

            // Update button
            if (step >= 4) {
                btn.textContent = 'Done';
                btn.disabled = true;
            } else {
                btn.textContent = 'Next Step';
                btn.disabled = false;
            }
        }

        function getMaxFlowResult() {
            const result = flowBuilderData.flowResult;
            if (!result) return 'Error computing flow.';

            const { maxFlow, totalGames, saturated } = result;

            if (saturated) {
                return `Step 4: <span style="color:#059669"><strong>Max Flow = ${maxFlow}</strong></span> (saturates all source edges). Target team <strong>survives!</strong>`;
            } else {
                // Show cut information
                const reachable = result.reachable;
                const cutNodes = Object.keys(reachable).filter(n => reachable[n] && n !== 's');
                const cutStr = cutNodes.length > 0 ? ` Min-cut S = {s, ${cutNodes.join(', ')}}` : '';
                return `Step 4: <span style="color:#c62828"><strong>Max Flow = ${maxFlow} < ${totalGames}</strong></span>. Target team is <strong>eliminated!</strong>${cutStr}`;
            }
        }

        function flowBuilderNextStep() {
            if (flowBuilderData.currentStep < 4) {
                flowBuilderData.currentStep++;
                renderFlowBuilderStep();
            }
        }

        function resetFlowBuilder() {
            // Go back to input phase
            document.getElementById('fb-input-phase').style.display = 'block';
            document.getElementById('fb-build-phase').style.display = 'none';
            flowBuilderData.currentStep = 0;
            document.getElementById('flow-next-btn').disabled = false;
            renderFlowBuilderStep();
        }

        // Certificate of Elimination Demo
        const certData = {
            teams: ['MI', 'CSK', 'KKR'],
            teamInfo: {
                'MI': { color: '#004BA0', textColor: '#FFD700', wins: 10 },
                'CSK': { color: '#FFCB05', textColor: '#0066B3', wins: 9 },
                'KKR': { color: '#3A225D', textColor: '#FFD700', wins: 8 }
            },
            games: { 'MI-CSK': 2, 'MI-KKR': 1, 'CSK-KKR': 2 },
            targetX: 10,
            blockingSubset: null
        };

        // Find blocking subset (certificate) - checks all non-empty subsets
        function findBlockingSubset() {
            const teams = certData.teams;
            const X = certData.targetX;

            // Check all non-empty subsets
            for (let mask = 1; mask < (1 << teams.length); mask++) {
                const subset = [];
                for (let i = 0; i < teams.length; i++) {
                    if (mask & (1 << i)) subset.push(teams[i]);
                }

                // Calculate w(S) and g(S)
                let wS = 0;
                subset.forEach(t => wS += certData.teamInfo[t].wins);

                let gS = 0;
                for (let i = 0; i < subset.length; i++) {
                    for (let j = i + 1; j < subset.length; j++) {
                        const key = [subset[i], subset[j]].sort().join('-');
                        // Try both orderings
                        gS += certData.games[subset[i] + '-' + subset[j]] || certData.games[subset[j] + '-' + subset[i]] || 0;
                    }
                }

                const avg = (wS + gS) / subset.length;
                if (avg > X) {
                    return { subset, wS, gS, avg };
                }
            }
            return null;
        }

        // Generate a random doomed instance (guaranteed elimination)
        function newCertificateInstance() {
            // Strategy: Generate instance where total remaining games > total slack
            // This guarantees elimination

            // Random wins between 8 and 11
            const miWins = Math.floor(Math.random() * 4) + 8;
            const cskWins = Math.floor(Math.random() * 4) + 8;
            const kkrWins = Math.floor(Math.random() * 4) + 8;

            // Target X = max wins (tight constraint, 0 slack for leader)
            const maxWins = Math.max(miWins, cskWins, kkrWins);
            const targetX = maxWins;

            // Calculate total slack
            const totalSlack = (targetX - miWins) + (targetX - cskWins) + (targetX - kkrWins);

            // Generate remaining games such that total > totalSlack
            // We need at least totalSlack + 1 games total
            const minGamesNeeded = totalSlack + 1;

            // Distribute games (ensure we exceed slack)
            let g1, g2, g3;
            do {
                g1 = Math.floor(Math.random() * 3) + 1; // 1-3
                g2 = Math.floor(Math.random() * 3) + 1;
                g3 = Math.floor(Math.random() * 3) + 1;
            } while (g1 + g2 + g3 <= totalSlack);

            // Update data
            certData.teamInfo['MI'].wins = miWins;
            certData.teamInfo['CSK'].wins = cskWins;
            certData.teamInfo['KKR'].wins = kkrWins;
            certData.games['MI-CSK'] = g1;
            certData.games['MI-KKR'] = g2;
            certData.games['CSK-KKR'] = g3;
            certData.targetX = targetX;
            certData.blockingSubset = findBlockingSubset();

            // Update display
            updateCertificateDisplay();

            // Hide reveal area and reset button
            document.getElementById('cert-reveal-area').style.display = 'none';
            document.getElementById('cert-reveal-btn').disabled = false;
            document.getElementById('certificate-result').innerHTML =
                'This instance is <strong>doomed</strong> — the target team is eliminated! Click <strong>Reveal Certificate</strong> to see why.';
        }

        function updateCertificateDisplay() {
            document.getElementById('cert-wins-mi').textContent = certData.teamInfo['MI'].wins;
            document.getElementById('cert-wins-csk').textContent = certData.teamInfo['CSK'].wins;
            document.getElementById('cert-wins-kkr').textContent = certData.teamInfo['KKR'].wins;
            document.getElementById('cert-games-mi-csk').textContent = certData.games['MI-CSK'];
            document.getElementById('cert-games-mi-kkr').textContent = certData.games['MI-KKR'];
            document.getElementById('cert-games-csk-kkr').textContent = certData.games['CSK-KKR'];
            document.getElementById('cert-target-x').textContent = certData.targetX;
        }

        function revealCertificate() {
            const teamsDiv = document.getElementById('certificate-teams');
            const calcDiv = document.getElementById('certificate-calc');
            const resultDiv = document.getElementById('certificate-result');
            const svg = document.getElementById('cert-svg');
            const revealArea = document.getElementById('cert-reveal-area');
            const btn = document.getElementById('cert-reveal-btn');

            if (!teamsDiv || !calcDiv || !resultDiv || !svg) return;

            const cert = certData.blockingSubset || findBlockingSubset();
            if (!cert) {
                resultDiv.innerHTML = '<span style="color: #059669;">No blocking subset found — this instance might be feasible!</span>';
                return;
            }

            // Show reveal area
            revealArea.style.display = 'block';
            btn.disabled = true;

            // Show blocking teams
            let teamsHTML = '';
            cert.subset.forEach(t => {
                const info = certData.teamInfo[t];
                teamsHTML += `<div style="padding: 6px 14px; background: ${info.color}; color: ${info.textColor}; border-radius: 20px; font-weight: 600; font-size: 0.9em;">${t}</div>`;
            });
            teamsDiv.innerHTML = teamsHTML;

            // Show calculation
            const winsStr = cert.subset.map(t => `w<sub>${t}</sub>`).join(' + ');
            const winsVals = cert.subset.map(t => certData.teamInfo[t].wins).join(' + ');

            // Calculate games within subset
            let gamesDesc = [];
            for (let i = 0; i < cert.subset.length; i++) {
                for (let j = i + 1; j < cert.subset.length; j++) {
                    const t1 = cert.subset[i], t2 = cert.subset[j];
                    const g = certData.games[t1 + '-' + t2] || certData.games[t2 + '-' + t1] || 0;
                    if (g > 0) gamesDesc.push(`${t1}-${t2}: ${g}`);
                }
            }

            calcDiv.innerHTML = `
                <p>w(S) = ${winsStr} = ${winsVals} = <strong>${cert.wS}</strong></p>
                <p style="margin-top: 4px;">g(S) = ${gamesDesc.length > 0 ? gamesDesc.join(' + ') : '0'} = <strong>${cert.gS}</strong></p>
                <p style="margin-top: 6px;">Average = (${cert.wS} + ${cert.gS}) / ${cert.subset.length} = <strong style="color: #c62828;">${cert.avg.toFixed(2)} > ${certData.targetX}</strong></p>
            `;

            // Draw visual
            drawCertificateSVG(svg, cert);

            resultDiv.innerHTML = `
                <span style="color: #c62828;"><strong>Certificate found!</strong></span>
                Even optimally, the average final wins for {${cert.subset.join(', ')}} must exceed ${certData.targetX}.
            `;
        }

        function drawCertificateSVG(svg, cert) {
            const subset = cert.subset;
            const n = subset.length;

            // Position nodes based on count (wider spacing for 3 teams)
            let positions = {};
            let winsLabelOffsets = {}; // Custom label offsets per team
            if (n === 1) {
                positions[subset[0]] = { x: 160, y: 90 };
                winsLabelOffsets[subset[0]] = { dx: 0, dy: 45 };
            } else if (n === 2) {
                positions[subset[0]] = { x: 100, y: 90 };
                positions[subset[1]] = { x: 220, y: 90 };
                winsLabelOffsets[subset[0]] = { dx: 0, dy: 45 };
                winsLabelOffsets[subset[1]] = { dx: 0, dy: 45 };
            } else if (n === 3) {
                // Wider triangle with more vertical spacing
                positions[subset[0]] = { x: 60, y: 110 };   // bottom-left
                positions[subset[1]] = { x: 160, y: 45 };   // top-center
                positions[subset[2]] = { x: 260, y: 110 };  // bottom-right
                // Wins labels: bottom teams go below, top team goes above
                winsLabelOffsets[subset[0]] = { dx: 0, dy: 45 };
                winsLabelOffsets[subset[1]] = { dx: 0, dy: -40 };
                winsLabelOffsets[subset[2]] = { dx: 0, dy: 45 };
            }

            let html = `<text x="160" y="18" text-anchor="middle" font-size="11" fill="#666" font-family="Heliotrope, Georgia, serif">Blocking Subset S</text>`;

            // Draw edges (games between teams)
            let edgeIndex = 0;
            for (let i = 0; i < subset.length; i++) {
                for (let j = i + 1; j < subset.length; j++) {
                    const t1 = subset[i], t2 = subset[j];
                    const g = certData.games[t1 + '-' + t2] || certData.games[t2 + '-' + t1] || 0;
                    if (g > 0) {
                        const p1 = positions[t1], p2 = positions[t2];
                        let mx = (p1.x + p2.x) / 2;
                        let my = (p1.y + p2.y) / 2;

                        // Offset edge labels for 3-team case to avoid overlap
                        if (n === 3) {
                            if (edgeIndex === 0) { my -= 12; mx -= 15; } // left edge
                            else if (edgeIndex === 1) { my += 15; }      // bottom edge
                            else if (edgeIndex === 2) { my -= 12; mx += 15; } // right edge
                        } else {
                            my -= 10;
                        }

                        html += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#333" stroke-width="2"/>`;
                        html += `<text x="${mx}" y="${my}" text-anchor="middle" font-size="9" fill="#333" font-family="Heliotrope, Georgia, serif">${g}</text>`;
                    }
                    edgeIndex++;
                }
            }

            // Draw nodes
            subset.forEach(t => {
                const pos = positions[t];
                const info = certData.teamInfo[t];
                const labelOff = winsLabelOffsets[t] || { dx: 0, dy: 45 };
                html += `<circle cx="${pos.x}" cy="${pos.y}" r="26" fill="${info.color}" stroke="#222" stroke-width="2"/>`;
                html += `<text x="${pos.x}" y="${pos.y + 4}" text-anchor="middle" font-size="11" font-weight="600" fill="${info.textColor}" font-family="Heliotrope, Georgia, serif">${t}</text>`;
                html += `<text x="${pos.x + labelOff.dx}" y="${pos.y + labelOff.dy}" text-anchor="middle" font-size="9" fill="#666" font-family="Heliotrope, Georgia, serif">${info.wins} wins</text>`;
            });

            svg.innerHTML = html;
        }

        function initCertificateDemo() {
            // Generate initial doomed instance
            newCertificateInstance();
        }

        // ========================================
        // Election Problem Interactive
        // ========================================

        const electionData = {
            people: [],       // { id, name, preference, prefWeight, x, y }
            friendships: [],  // { id, person1, person2, weight }
            mode: 'select',   // 'select', 'connect', 'delete'
            selectedPerson: null,
            connectingFrom: null,
            nextPersonId: 1,
            nextFriendshipId: 1,
            flowResult: null,
            userVotes: {},    // For what-if mode
            whatIfMode: false
        };

        // Pre-built scenarios
        const electionScenarios = {
            dinner: {
                name: "The Dinner Party",
                description: "4 people with cross-party friendships. Everyone voting their preference is optimal!",
                people: [
                    { id: 1, name: "Alice", preference: "A", prefWeight: 2, x: 120, y: 80 },
                    { id: 2, name: "Bob", preference: "A", prefWeight: 2, x: 120, y: 180 },
                    { id: 3, name: "Carol", preference: "B", prefWeight: 2, x: 280, y: 80 },
                    { id: 4, name: "Dave", preference: "B", prefWeight: 2, x: 280, y: 180 }
                ],
                friendships: [
                    { id: 1, person1: 1, person2: 3, weight: 3 },  // Alice-Carol
                    { id: 2, person1: 2, person2: 4, weight: 3 }   // Bob-Dave
                ]
            },
            influencer: {
                name: "The Influencer",
                description: "One A-supporter with many B-supporter friends. Social pressure may flip their vote!",
                people: [
                    { id: 1, name: "Influencer", preference: "A", prefWeight: 3, x: 200, y: 130 },
                    { id: 2, name: "Fan1", preference: "B", prefWeight: 2, x: 80, y: 60 },
                    { id: 3, name: "Fan2", preference: "B", prefWeight: 2, x: 320, y: 60 },
                    { id: 4, name: "Fan3", preference: "B", prefWeight: 2, x: 80, y: 200 },
                    { id: 5, name: "Fan4", preference: "B", prefWeight: 2, x: 320, y: 200 }
                ],
                friendships: [
                    { id: 1, person1: 1, person2: 2, weight: 4 },
                    { id: 2, person1: 1, person2: 3, weight: 4 },
                    { id: 3, person1: 1, person2: 4, weight: 4 },
                    { id: 4, person1: 1, person2: 5, weight: 4 }
                ]
            },
            communities: {
                name: "Two Communities",
                description: "Two tight-knit groups with a bridge friendship. The cut follows community lines.",
                people: [
                    { id: 1, name: "A1", preference: "A", prefWeight: 3, x: 80, y: 70 },
                    { id: 2, name: "A2", preference: "A", prefWeight: 3, x: 80, y: 190 },
                    { id: 3, name: "A3", preference: "A", prefWeight: 3, x: 160, y: 130 },
                    { id: 4, name: "B1", preference: "B", prefWeight: 3, x: 320, y: 70 },
                    { id: 5, name: "B2", preference: "B", prefWeight: 3, x: 320, y: 190 },
                    { id: 6, name: "B3", preference: "B", prefWeight: 3, x: 240, y: 130 }
                ],
                friendships: [
                    { id: 1, person1: 1, person2: 2, weight: 5 },
                    { id: 2, person1: 1, person2: 3, weight: 5 },
                    { id: 3, person1: 2, person2: 3, weight: 5 },
                    { id: 4, person1: 4, person2: 5, weight: 5 },
                    { id: 5, person1: 4, person2: 6, weight: 5 },
                    { id: 6, person1: 5, person2: 6, weight: 5 },
                    { id: 7, person1: 3, person2: 6, weight: 2 }  // Bridge
                ]
            },
            swing: {
                name: "The Swing Voter",
                description: "One person with weak preference is friends with both sides. They might switch!",
                people: [
                    { id: 1, name: "Strong A", preference: "A", prefWeight: 5, x: 80, y: 80 },
                    { id: 2, name: "Strong B", preference: "B", prefWeight: 5, x: 320, y: 80 },
                    { id: 3, name: "Swing", preference: "A", prefWeight: 1, x: 200, y: 130 },
                    { id: 4, name: "Ally A", preference: "A", prefWeight: 3, x: 80, y: 180 },
                    { id: 5, name: "Ally B", preference: "B", prefWeight: 3, x: 320, y: 180 }
                ],
                friendships: [
                    { id: 1, person1: 1, person2: 3, weight: 2 },
                    { id: 2, person1: 2, person2: 3, weight: 4 },
                    { id: 3, person1: 1, person2: 4, weight: 3 },
                    { id: 4, person1: 2, person2: 5, weight: 3 },
                    { id: 5, person1: 3, person2: 5, weight: 3 }
                ]
            }
        };

        function loadElectionScenario() {
            const select = document.getElementById('election-scenario');
            const scenario = select.value;

            if (scenario === 'custom') {
                clearElectionNetwork();
                return;
            }

            const data = electionScenarios[scenario];
            if (!data) return;

            electionData.people = JSON.parse(JSON.stringify(data.people));
            electionData.friendships = JSON.parse(JSON.stringify(data.friendships));
            electionData.nextPersonId = Math.max(...data.people.map(p => p.id)) + 1;
            electionData.nextFriendshipId = data.friendships.length > 0 ?
                Math.max(...data.friendships.map(f => f.id)) + 1 : 1;
            electionData.selectedPerson = null;
            electionData.connectingFrom = null;

            renderElectionSocialNetwork();
            updateElectionOutput(`Loaded: <strong>${data.name}</strong>. ${data.description}`);
        }

        function clearElectionNetwork() {
            electionData.people = [];
            electionData.friendships = [];
            electionData.nextPersonId = 1;
            electionData.nextFriendshipId = 1;
            electionData.selectedPerson = null;
            electionData.connectingFrom = null;
            document.getElementById('election-scenario').value = 'custom';
            renderElectionSocialNetwork();
            updateElectionPropsPanel();
            updateElectionOutput('Network cleared. Add people and connect friends to build your community.');
        }

        function addElectionPerson(preference) {
            // Use viewBox coordinates (420 x 280)
            // Random position within canvas with padding
            const x = 60 + Math.random() * 300;  // 60 to 360
            const y = 50 + Math.random() * 180;  // 50 to 230

            const person = {
                id: electionData.nextPersonId++,
                name: `P${electionData.people.length + 1}`,
                preference: preference,
                prefWeight: 3,
                x: x,
                y: y
            };

            electionData.people.push(person);
            document.getElementById('election-scenario').value = 'custom';
            renderElectionSocialNetwork();
            updateElectionOutput(`Added <strong>${person.name}</strong> (prefers ${preference}).`);
        }

        function toggleElectionMode(mode) {
            electionData.mode = mode;
            electionData.connectingFrom = null;

            // Update button styles
            ['select', 'connect', 'delete'].forEach(m => {
                const btn = document.getElementById('election-mode-' + m);
                if (btn) {
                    btn.style.background = m === mode ? '#3B82F6' : '';
                    btn.style.color = m === mode ? 'white' : '';
                }
            });

            const modeText = {
                select: 'Select mode — click a person to edit their properties.',
                connect: 'Connect mode — click two people to add a friendship.',
                delete: 'Delete mode — click a person or edge to remove it.'
            };
            updateElectionOutput(modeText[mode]);
        }

        function renderElectionSocialNetwork() {
            const svg = document.getElementById('election-social-svg');
            if (!svg) return;

            // Positions are stored in viewBox coordinates (420 x 280)
            let html = '';

            // Draw friendships
            electionData.friendships.forEach(f => {
                const p1 = electionData.people.find(p => p.id === f.person1);
                const p2 = electionData.people.find(p => p.id === f.person2);
                if (!p1 || !p2) return;

                const mx = (p1.x + p2.x) / 2;
                const my = (p1.y + p2.y) / 2;

                html += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"
                         stroke="#8B5CF6" stroke-width="${Math.min(f.weight, 8)}"
                         style="cursor: pointer;" onclick="clickElectionFriendship(${f.id})"/>`;
                html += `<text x="${mx}" y="${my - 8}" text-anchor="middle" font-size="11"
                         fill="#6B21A8" font-weight="600" style="pointer-events: none;">${f.weight}</text>`;
            });

            // Draw connecting line if in connect mode
            if (electionData.connectingFrom && electionData.mode === 'connect') {
                const p = electionData.people.find(p => p.id === electionData.connectingFrom);
                if (p) {
                    html += `<line id="election-connect-line" x1="${p.x}" y1="${p.y}" x2="${p.x}" y2="${p.y}"
                             stroke="#8B5CF6" stroke-width="2" stroke-dasharray="5,3" style="pointer-events: none;"/>`;
                }
            }

            // Draw people
            electionData.people.forEach(p => {
                const isSelected = electionData.selectedPerson === p.id;
                const isConnecting = electionData.connectingFrom === p.id;
                const fillColor = p.preference === 'A' ? '#3B82F6' : '#EF4444';
                const strokeColor = isSelected || isConnecting ? '#F59E0B' : '#1F2937';
                const strokeWidth = isSelected || isConnecting ? 4 : 2;

                html += `<circle cx="${p.x}" cy="${p.y}" r="${18 + p.prefWeight}"
                         fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"
                         style="cursor: pointer;" onclick="clickElectionPerson(${p.id})"
                         onmousedown="startDragPerson(event, ${p.id})"/>`;
                html += `<text x="${p.x}" y="${p.y + 4}" text-anchor="middle"
                         font-size="11" font-weight="600" fill="white" style="pointer-events: none;">${p.name}</text>`;

                // Preference weight indicator
                html += `<text x="${p.x}" y="${p.y + 30 + p.prefWeight}" text-anchor="middle"
                         font-size="9" fill="#666" style="pointer-events: none;">p=${p.prefWeight}</text>`;
            });

            svg.innerHTML = html;
        }

        function clickElectionPerson(id) {
            const mode = electionData.mode;

            if (mode === 'select') {
                electionData.selectedPerson = id;
                updateElectionPropsPanel();
                renderElectionSocialNetwork();
            } else if (mode === 'connect') {
                if (!electionData.connectingFrom) {
                    electionData.connectingFrom = id;
                    renderElectionSocialNetwork();
                    updateElectionOutput('Now click another person to connect them as friends.');
                } else if (electionData.connectingFrom !== id) {
                    // Check if friendship already exists
                    const existing = electionData.friendships.find(f =>
                        (f.person1 === electionData.connectingFrom && f.person2 === id) ||
                        (f.person1 === id && f.person2 === electionData.connectingFrom)
                    );
                    if (!existing) {
                        electionData.friendships.push({
                            id: electionData.nextFriendshipId++,
                            person1: electionData.connectingFrom,
                            person2: id,
                            weight: 3
                        });
                        document.getElementById('election-scenario').value = 'custom';
                        updateElectionOutput('Friendship created!');
                    } else {
                        updateElectionOutput('These people are already friends.');
                    }
                    electionData.connectingFrom = null;
                    renderElectionSocialNetwork();
                } else {
                    electionData.connectingFrom = null;
                    renderElectionSocialNetwork();
                }
            } else if (mode === 'delete') {
                electionData.people = electionData.people.filter(p => p.id !== id);
                electionData.friendships = electionData.friendships.filter(f =>
                    f.person1 !== id && f.person2 !== id
                );
                document.getElementById('election-scenario').value = 'custom';
                renderElectionSocialNetwork();
                updateElectionPropsPanel();
                updateElectionOutput('Person deleted.');
            }
        }

        function clickElectionFriendship(id) {
            const mode = electionData.mode;

            if (mode === 'select') {
                const f = electionData.friendships.find(f => f.id === id);
                if (f) {
                    updateElectionPropsPanel(f);
                }
            } else if (mode === 'delete') {
                electionData.friendships = electionData.friendships.filter(f => f.id !== id);
                document.getElementById('election-scenario').value = 'custom';
                renderElectionSocialNetwork();
                updateElectionOutput('Friendship deleted.');
            }
        }

        function updateElectionPropsPanel(friendship = null) {
            const content = document.getElementById('election-props-content');
            if (!content) return;

            if (friendship) {
                const p1 = electionData.people.find(p => p.id === friendship.person1);
                const p2 = electionData.people.find(p => p.id === friendship.person2);
                content.innerHTML = `
                    <p style="margin-bottom: 8px;"><strong>Friendship</strong></p>
                    <p style="margin-bottom: 8px;">${p1?.name || '?'} ↔ ${p2?.name || '?'}</p>
                    <label style="display: block; margin-bottom: 5px;">Penalty Weight:</label>
                    <input type="range" min="1" max="10" value="${friendship.weight}"
                           onchange="updateFriendshipWeight(${friendship.id}, this.value)"
                           style="width: 100%;">
                    <span id="friendship-weight-display">${friendship.weight}</span>
                `;
                return;
            }

            const personId = electionData.selectedPerson;
            if (!personId) {
                content.innerHTML = '<p style="color: #999; font-style: italic;">Click a person or friendship to edit</p>';
                return;
            }

            const person = electionData.people.find(p => p.id === personId);
            if (!person) return;

            const prefColor = person.preference === 'A' ? '#3B82F6' : '#EF4444';

            content.innerHTML = `
                <p style="margin-bottom: 10px;"><strong style="color: ${prefColor};">${person.name}</strong></p>
                <label style="display: block; margin-bottom: 5px;">Name:</label>
                <input type="text" value="${person.name}" maxlength="8"
                       onchange="updatePersonName(${person.id}, this.value)"
                       style="width: 100%; padding: 4px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <label style="display: block; margin-bottom: 5px;">Preference:</label>
                <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                    <button onclick="updatePersonPref(${person.id}, 'A')"
                            style="flex: 1; padding: 5px; background: ${person.preference === 'A' ? '#3B82F6' : '#e0e0e0'};
                                   color: ${person.preference === 'A' ? 'white' : '#666'}; border: none; border-radius: 4px; cursor: pointer;">A</button>
                    <button onclick="updatePersonPref(${person.id}, 'B')"
                            style="flex: 1; padding: 5px; background: ${person.preference === 'B' ? '#EF4444' : '#e0e0e0'};
                                   color: ${person.preference === 'B' ? 'white' : '#666'}; border: none; border-radius: 4px; cursor: pointer;">B</button>
                </div>
                <label style="display: block; margin-bottom: 5px;">Preference Strength: <span id="pref-weight-display">${person.prefWeight}</span></label>
                <input type="range" min="1" max="10" value="${person.prefWeight}"
                       onchange="updatePersonPrefWeight(${person.id}, this.value)"
                       style="width: 100%;">
            `;
        }

        function updatePersonName(id, name) {
            const person = electionData.people.find(p => p.id === id);
            if (person) {
                person.name = name.substring(0, 8);
                document.getElementById('election-scenario').value = 'custom';
                renderElectionSocialNetwork();
            }
        }

        function updatePersonPref(id, pref) {
            const person = electionData.people.find(p => p.id === id);
            if (person) {
                person.preference = pref;
                document.getElementById('election-scenario').value = 'custom';
                renderElectionSocialNetwork();
                updateElectionPropsPanel();
            }
        }

        function updatePersonPrefWeight(id, weight) {
            const person = electionData.people.find(p => p.id === id);
            if (person) {
                person.prefWeight = parseInt(weight);
                document.getElementById('election-scenario').value = 'custom';
                document.getElementById('pref-weight-display').textContent = weight;
                renderElectionSocialNetwork();
            }
        }

        function updateFriendshipWeight(id, weight) {
            const friendship = electionData.friendships.find(f => f.id === id);
            if (friendship) {
                friendship.weight = parseInt(weight);
                document.getElementById('election-scenario').value = 'custom';
                document.getElementById('friendship-weight-display').textContent = weight;
                renderElectionSocialNetwork();
            }
        }

        function updateElectionOutput(msg) {
            const output = document.getElementById('election-social-output');
            if (output) output.innerHTML = msg;
        }

        // Drag functionality for repositioning people
        let draggingPerson = null;
        let dragOffset = { x: 0, y: 0 };

        // Convert pixel coordinates to viewBox coordinates
        function pixelToViewBox(svg, pixelX, pixelY) {
            const rect = svg.getBoundingClientRect();
            // ViewBox is 420 x 280
            const viewBoxWidth = 420;
            const viewBoxHeight = 280;
            return {
                x: (pixelX / rect.width) * viewBoxWidth,
                y: (pixelY / rect.height) * viewBoxHeight
            };
        }

        function startDragPerson(event, id) {
            if (electionData.mode !== 'select') return;

            draggingPerson = id;
            const person = electionData.people.find(p => p.id === id);
            const svg = document.getElementById('election-social-svg');
            const rect = svg.getBoundingClientRect();

            const viewBoxCoords = pixelToViewBox(svg, event.clientX - rect.left, event.clientY - rect.top);
            dragOffset = { x: viewBoxCoords.x - person.x, y: viewBoxCoords.y - person.y };

            document.addEventListener('mousemove', dragPerson);
            document.addEventListener('mouseup', stopDragPerson);
            event.preventDefault();
        }

        function dragPerson(event) {
            if (!draggingPerson) return;

            const person = electionData.people.find(p => p.id === draggingPerson);
            const svg = document.getElementById('election-social-svg');
            const rect = svg.getBoundingClientRect();

            const viewBoxCoords = pixelToViewBox(svg, event.clientX - rect.left, event.clientY - rect.top);

            // Clamp to viewBox bounds (420 x 280) with padding
            person.x = Math.max(35, Math.min(385, viewBoxCoords.x - dragOffset.x));
            person.y = Math.max(35, Math.min(245, viewBoxCoords.y - dragOffset.y));

            document.getElementById('election-scenario').value = 'custom';
            renderElectionSocialNetwork();
        }

        function stopDragPerson() {
            draggingPerson = null;
            document.removeEventListener('mousemove', dragPerson);
            document.removeEventListener('mouseup', stopDragPerson);
        }

        // Build Flow Network
        function buildElectionFlowNetwork() {
            if (electionData.people.length < 2) {
                updateElectionOutput('<span style="color: #c62828;">Add at least 2 people to build a network.</span>');
                return;
            }

            // Navigate to flow network slide
            Reveal.next();

            // Render both views
            setTimeout(() => {
                renderElectionFlowNetwork();
                renderElectionSocialMini();
                document.getElementById('election-flow-output').innerHTML =
                    'The flow network is ready. Click <strong>Run Max-Flow</strong> to find the optimal voting assignment.';
            }, 100);
        }

        function renderElectionSocialMini() {
            const svg = document.getElementById('election-social-mini');
            if (!svg) return;

            // Use fixed viewBox dimensions (250 x 180)
            // Scale from social network coords (roughly 400x280) to mini view
            const scaleX = 250 / 420;
            const scaleY = 180 / 280;
            const scale = Math.min(scaleX, scaleY) * 0.85; // Slightly smaller to fit with padding

            let html = '';

            // Draw friendships (scaled down)
            electionData.friendships.forEach(f => {
                const p1 = electionData.people.find(p => p.id === f.person1);
                const p2 = electionData.people.find(p => p.id === f.person2);
                if (!p1 || !p2) return;

                html += `<line x1="${p1.x * scale + 20}" y1="${p1.y * scale + 10}" x2="${p2.x * scale + 20}" y2="${p2.y * scale + 10}"
                         stroke="#8B5CF6" stroke-width="${Math.min(f.weight * 0.6, 5)}"/>`;
            });

            // Draw people (scaled down)
            electionData.people.forEach(p => {
                const fillColor = p.preference === 'A' ? '#3B82F6' : '#EF4444';
                const r = (10 + p.prefWeight * 0.4) * scale + 4;

                html += `<circle cx="${p.x * scale + 20}" cy="${p.y * scale + 10}" r="${r}"
                         fill="${fillColor}" stroke="#1F2937" stroke-width="1.5"/>`;
                html += `<text x="${p.x * scale + 20}" y="${p.y * scale + 13}" text-anchor="middle"
                         font-size="8" font-weight="600" fill="white">${p.name.substring(0, 3)}</text>`;
            });

            svg.innerHTML = html;
        }

        function renderElectionFlowNetwork() {
            const svg = document.getElementById('election-flow-svg');
            if (!svg) return;

            // Use fixed dimensions matching the viewBox (600 x 260)
            const width = 600;
            const height = 260;
            const nodeRadius = 16;

            // 4-column layout: s | A-voters | B-voters | t
            const colS = 50;        // Source column
            const colA = 190;       // A-preferring people column
            const colB = 410;       // B-preferring people column
            const colT = width - 50; // Sink column

            const sPos = { x: colS, y: height / 2 };
            const tPos = { x: colT, y: height / 2 };

            // Separate people by preference
            const aVoters = electionData.people.filter(p => p.preference === 'A');
            const bVoters = electionData.people.filter(p => p.preference === 'B');

            // Calculate positions for each group with comfortable spacing
            const personPositions = {};

            aVoters.forEach((p, i) => {
                const y = 35 + (height - 70) * (i / Math.max(aVoters.length - 1, 1));
                personPositions[p.id] = { x: colA, y: aVoters.length === 1 ? height / 2 : y };
            });

            bVoters.forEach((p, i) => {
                const y = 35 + (height - 70) * (i / Math.max(bVoters.length - 1, 1));
                personPositions[p.id] = { x: colB, y: bVoters.length === 1 ? height / 2 : y };
            });

            let html = `<defs>
                <marker id="election-arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#555"/>
                </marker>
                <marker id="election-arrow-blue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#3B82F6"/>
                </marker>
                <marker id="election-arrow-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#EF4444"/>
                </marker>
                <marker id="election-arrow-purple" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" fill="#8B5CF6"/>
                </marker>
            </defs>`;

            // Source node
            const stRadius = 18;
            html += `<circle cx="${sPos.x}" cy="${sPos.y}" r="${stRadius}" fill="#a8d4f0" stroke="#1E40AF" stroke-width="2"/>`;
            html += `<text x="${sPos.x}" y="${sPos.y + 5}" text-anchor="middle" font-size="13" font-weight="600" fill="#1E40AF">s</text>`;

            // Sink node
            html += `<circle cx="${tPos.x}" cy="${tPos.y}" r="${stRadius}" fill="#f5c4c0" stroke="#991B1B" stroke-width="2"/>`;
            html += `<text x="${tPos.x}" y="${tPos.y + 5}" text-anchor="middle" font-size="13" font-weight="600" fill="#991B1B">t</text>`;

            // Draw edges from source to A-preferring people (horizontal)
            aVoters.forEach(p => {
                const pos = personPositions[p.id];
                html += `<line x1="${sPos.x + stRadius}" y1="${sPos.y}" x2="${pos.x - nodeRadius}" y2="${pos.y}"
                         stroke="#3B82F6" stroke-width="1.5" marker-end="url(#election-arrow-blue)"/>`;
                const mx = (sPos.x + pos.x) / 2;
                const my = (sPos.y + pos.y) / 2 - 5;
                html += `<text x="${mx}" y="${my}" text-anchor="middle" font-size="9" fill="#3B82F6" font-weight="600">${p.prefWeight}</text>`;
            });

            // Draw edges from B-preferring people to sink (horizontal)
            bVoters.forEach(p => {
                const pos = personPositions[p.id];
                html += `<line x1="${pos.x + nodeRadius}" y1="${pos.y}" x2="${tPos.x - stRadius}" y2="${tPos.y}"
                         stroke="#EF4444" stroke-width="1.5" marker-end="url(#election-arrow-red)"/>`;
                const mx = (pos.x + tPos.x) / 2;
                const my = (pos.y + tPos.y) / 2 - 5;
                html += `<text x="${mx}" y="${my}" text-anchor="middle" font-size="9" fill="#EF4444" font-weight="600">${p.prefWeight}</text>`;
            });

            // Draw friendship edges (bidirectional) - these now span horizontally between columns
            electionData.friendships.forEach(f => {
                const p1 = electionData.people.find(p => p.id === f.person1);
                const p2 = electionData.people.find(p => p.id === f.person2);
                if (!p1 || !p2) return;

                const pos1 = personPositions[p1.id];
                const pos2 = personPositions[p2.id];
                if (!pos1 || !pos2) return;

                // Offset for bidirectional arrows
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const len = Math.sqrt(dx*dx + dy*dy) || 1;
                const ox = -dy / len * 3;
                const oy = dx / len * 3;

                // Calculate edge endpoints accounting for node radius
                const ux = dx / len;
                const uy = dy / len;

                html += `<line x1="${pos1.x + nodeRadius * ux + ox}" y1="${pos1.y + nodeRadius * uy + oy}"
                         x2="${pos2.x - nodeRadius * ux + ox}" y2="${pos2.y - nodeRadius * uy + oy}"
                         stroke="#8B5CF6" stroke-width="1.5" marker-end="url(#election-arrow-purple)"/>`;
                html += `<line x1="${pos2.x - nodeRadius * ux - ox}" y1="${pos2.y - nodeRadius * uy - oy}"
                         x2="${pos1.x + nodeRadius * ux - ox}" y2="${pos1.y + nodeRadius * uy - oy}"
                         stroke="#8B5CF6" stroke-width="1.5" marker-end="url(#election-arrow-purple)"/>`;

                const mx = (pos1.x + pos2.x) / 2;
                const my = (pos1.y + pos2.y) / 2 - 8;
                html += `<text x="${mx}" y="${my}" text-anchor="middle" font-size="9" fill="#6B21A8" font-weight="700">${f.weight}</text>`;
            });

            // Draw person nodes
            electionData.people.forEach(p => {
                const pos = personPositions[p.id];
                if (!pos) return;
                const fillColor = p.preference === 'A' ? '#DBEAFE' : '#FEE2E2';
                const strokeColor = p.preference === 'A' ? '#3B82F6' : '#EF4444';

                html += `<circle cx="${pos.x}" cy="${pos.y}" r="${nodeRadius}" fill="${fillColor}" stroke="${strokeColor}" stroke-width="2"/>`;
                html += `<text x="${pos.x}" y="${pos.y + 4}" text-anchor="middle" font-size="9" font-weight="600" fill="#333">${p.name}</text>`;
            });

            svg.innerHTML = html;
        }

        function resetElectionToSocial() {
            // Go back to social network builder
            const currentSlide = Reveal.getIndices();
            Reveal.slide(currentSlide.h, currentSlide.v - (currentSlide.v > 0 ? 1 : 0));
        }

        // Run Max-Flow algorithm for election
        function runElectionMaxFlow() {
            const result = computeElectionMaxFlow();
            electionData.flowResult = result;

            // Initialize user votes with optimal
            electionData.userVotes = { ...result.votes };
            electionData.whatIfMode = false;

            // Navigate to results slide
            Reveal.next();

            setTimeout(() => {
                renderElectionResults();
            }, 100);
        }

        function computeElectionMaxFlow() {
            const people = electionData.people;
            const friendships = electionData.friendships;

            // Build adjacency structure
            const nodes = ['s', 't', ...people.map(p => 'p' + p.id)];
            const capacity = {};
            const flow = {};

            nodes.forEach(u => {
                capacity[u] = {};
                flow[u] = {};
                nodes.forEach(v => {
                    capacity[u][v] = 0;
                    flow[u][v] = 0;
                });
            });

            // Add preference edges
            people.forEach(p => {
                const node = 'p' + p.id;
                if (p.preference === 'A') {
                    capacity['s'][node] = p.prefWeight;
                } else {
                    capacity[node]['t'] = p.prefWeight;
                }
            });

            // Add friendship edges (bidirectional)
            friendships.forEach(f => {
                const n1 = 'p' + f.person1;
                const n2 = 'p' + f.person2;
                capacity[n1][n2] = f.weight;
                capacity[n2][n1] = f.weight;
            });

            // BFS for augmenting paths
            let maxFlowValue = 0;
            while (true) {
                const parent = { 's': null };
                const queue = ['s'];
                let found = false;

                while (queue.length > 0 && !found) {
                    const u = queue.shift();
                    for (const v of nodes) {
                        if (!(v in parent) && capacity[u][v] - flow[u][v] > 0) {
                            parent[v] = u;
                            if (v === 't') {
                                found = true;
                                break;
                            }
                            queue.push(v);
                        }
                    }
                }

                if (!found) break;

                // Find bottleneck
                let pathFlow = Infinity;
                let v = 't';
                while (v !== 's') {
                    const u = parent[v];
                    pathFlow = Math.min(pathFlow, capacity[u][v] - flow[u][v]);
                    v = u;
                }

                // Update flow
                v = 't';
                while (v !== 's') {
                    const u = parent[v];
                    flow[u][v] += pathFlow;
                    flow[v][u] -= pathFlow;
                    v = u;
                }

                maxFlowValue += pathFlow;
            }

            // Find min-cut (reachable from s)
            const reachable = { 's': true };
            const queue = ['s'];
            while (queue.length > 0) {
                const u = queue.shift();
                for (const v of nodes) {
                    if (!reachable[v] && capacity[u][v] - flow[u][v] > 0) {
                        reachable[v] = true;
                        queue.push(v);
                    }
                }
            }

            // Determine votes from cut
            const votes = {};
            people.forEach(p => {
                const node = 'p' + p.id;
                votes[p.id] = reachable[node] ? 'A' : 'B';
            });

            // Calculate penalty breakdown
            let prefPenalty = 0;
            let friendPenalty = 0;
            const prefPenalties = [];
            const friendPenalties = [];

            people.forEach(p => {
                if (votes[p.id] !== p.preference) {
                    prefPenalty += p.prefWeight;
                    prefPenalties.push({ name: p.name, pref: p.preference, vote: votes[p.id], penalty: p.prefWeight });
                }
            });

            friendships.forEach(f => {
                if (votes[f.person1] !== votes[f.person2]) {
                    friendPenalty += f.weight;
                    const p1 = people.find(p => p.id === f.person1);
                    const p2 = people.find(p => p.id === f.person2);
                    friendPenalties.push({ n1: p1.name, n2: p2.name, penalty: f.weight });
                }
            });

            return {
                maxFlow: maxFlowValue,
                votes: votes,
                reachable: reachable,
                prefPenalty: prefPenalty,
                friendPenalty: friendPenalty,
                totalPenalty: prefPenalty + friendPenalty,
                prefPenalties: prefPenalties,
                friendPenalties: friendPenalties
            };
        }

        function renderElectionResults() {
            const result = electionData.flowResult;
            if (!result) return;

            const votes = electionData.whatIfMode ? electionData.userVotes : result.votes;

            // Count votes
            let votesA = 0, votesB = 0;
            electionData.people.forEach(p => {
                if (votes[p.id] === 'A') votesA++;
                else votesB++;
            });

            document.getElementById('election-votes-a').textContent = votesA;
            document.getElementById('election-votes-b').textContent = votesB;

            // Calculate penalties for current votes
            let prefPenalty = 0, friendPenalty = 0;
            const prefItems = [], friendItems = [];

            electionData.people.forEach(p => {
                if (votes[p.id] !== p.preference) {
                    prefPenalty += p.prefWeight;
                    prefItems.push(`${p.name} (prefers ${p.preference}) → votes ${votes[p.id]}: <strong>${p.prefWeight}</strong>`);
                }
            });

            electionData.friendships.forEach(f => {
                if (votes[f.person1] !== votes[f.person2]) {
                    friendPenalty += f.weight;
                    const p1 = electionData.people.find(p => p.id === f.person1);
                    const p2 = electionData.people.find(p => p.id === f.person2);
                    friendItems.push(`${p1.name} ↔ ${p2.name} vote differently: <strong>${f.weight}</strong>`);
                }
            });

            const totalPenalty = prefPenalty + friendPenalty;

            // Update penalty breakdown
            let breakdownHtml = '';
            if (prefItems.length > 0) {
                breakdownHtml += `<div style="margin-bottom: 5px;"><em>Preference:</em></div>`;
                breakdownHtml += prefItems.map(s => `<div style="margin-left: 10px; font-size: 0.85em;">${s}</div>`).join('');
            }
            if (friendItems.length > 0) {
                breakdownHtml += `<div style="margin-top: 5px; margin-bottom: 5px;"><em>Friendship:</em></div>`;
                breakdownHtml += friendItems.map(s => `<div style="margin-left: 10px; font-size: 0.85em;">${s}</div>`).join('');
            }
            if (breakdownHtml === '') {
                breakdownHtml = '<p style="color: #059669;">No penalties! Everyone votes their preference and all friends agree.</p>';
            }

            document.getElementById('election-penalty-breakdown').innerHTML = breakdownHtml;
            document.getElementById('election-total-penalty').textContent = totalPenalty;

            // Update what-if panel if visible
            if (electionData.whatIfMode) {
                document.getElementById('election-user-penalty').textContent = totalPenalty;
                document.getElementById('election-opt-penalty').textContent = result.totalPenalty;
                const diff = totalPenalty - result.totalPenalty;
                const diffSpan = document.getElementById('election-diff-penalty');
                diffSpan.textContent = diff > 0 ? '+' + diff : diff;
                diffSpan.style.color = diff > 0 ? '#DC2626' : '#059669';
            }

            // Render visualization
            renderElectionResultSVG();

            // Update output
            const output = document.getElementById('election-result-output');
            if (output) {
                if (electionData.whatIfMode) {
                    output.innerHTML = 'Click on people to toggle their votes. Compare your assignment with the optimal!';
                } else {
                    output.innerHTML = `<strong>Min-Cut Capacity = ${result.totalPenalty}</strong>. ` +
                        (result.totalPenalty === 0 ? 'Perfect harmony — no penalties!' :
                        `This is the minimum possible total penalty.`);
                }
            }
        }

        function renderElectionResultSVG() {
            const svg = document.getElementById('election-result-svg');
            if (!svg) return;

            const result = electionData.flowResult;
            const votes = electionData.whatIfMode ? electionData.userVotes : result.votes;

            // Use fixed dimensions matching the viewBox (500 x 270)
            const width = 500;
            const height = 270;
            const nodeRadius = 18;

            // Separate people by vote (treat undefined/missing as 'B' to be safe)
            const votingA = electionData.people.filter(p => votes[p.id] === 'A');
            const votingB = electionData.people.filter(p => votes[p.id] !== 'A');

            // Calculate positions with comfortable spacing
            const positions = {};
            const leftX = width * 0.25;
            const rightX = width * 0.75;

            votingA.forEach((p, i) => {
                const y = 40 + (height - 80) * (i / Math.max(votingA.length - 1, 1));
                positions[p.id] = { x: leftX, y: votingA.length === 1 ? height / 2 : y };
            });

            votingB.forEach((p, i) => {
                const y = 40 + (height - 80) * (i / Math.max(votingB.length - 1, 1));
                positions[p.id] = { x: rightX, y: votingB.length === 1 ? height / 2 : y };
            });

            let html = '';

            // Draw cut line
            html += `<line x1="${width / 2}" y1="10" x2="${width / 2}" y2="${height - 10}"
                     stroke="#F59E0B" stroke-width="3" stroke-dasharray="8,4"/>`;
            html += `<text x="${width / 2}" y="${height - 2}" text-anchor="middle" font-size="10" fill="#F59E0B" font-weight="600">MIN CUT</text>`;

            // Labels
            html += `<text x="${leftX}" y="18" text-anchor="middle" font-size="11" fill="#3B82F6" font-weight="600">Votes for A</text>`;
            html += `<text x="${rightX}" y="18" text-anchor="middle" font-size="11" fill="#EF4444" font-weight="600">Votes for B</text>`;

            // Draw friendship edges
            electionData.friendships.forEach(f => {
                const p1 = electionData.people.find(p => p.id === f.person1);
                const p2 = electionData.people.find(p => p.id === f.person2);
                if (!p1 || !p2) return;

                const pos1 = positions[p1.id];
                const pos2 = positions[p2.id];
                if (!pos1 || !pos2) return;

                const isCut = votes[f.person1] !== votes[f.person2];

                html += `<line x1="${pos1.x}" y1="${pos1.y}" x2="${pos2.x}" y2="${pos2.y}"
                         stroke="${isCut ? '#F59E0B' : '#8B5CF6'}" stroke-width="${isCut ? 3 : 2}"
                         ${isCut ? 'stroke-dasharray="5,3"' : ''}/>`;

                if (isCut) {
                    const mx = (pos1.x + pos2.x) / 2;
                    const my = (pos1.y + pos2.y) / 2;
                    html += `<text x="${mx}" y="${my - 5}" text-anchor="middle" font-size="10" fill="#F59E0B" font-weight="700">${f.weight}</text>`;
                }
            });

            // Draw people
            electionData.people.forEach(p => {
                const pos = positions[p.id];
                if (!pos) return;

                const vote = votes[p.id];
                const votedAgainstPref = vote !== p.preference;

                const fillColor = vote === 'A' ? '#3B82F6' : '#EF4444';
                const strokeColor = votedAgainstPref ? '#F59E0B' : '#1F2937';
                const strokeWidth = votedAgainstPref ? 3 : 2;

                const clickHandler = electionData.whatIfMode ? `onclick="toggleElectionVote(${p.id})"` : '';
                const cursor = electionData.whatIfMode ? 'cursor: pointer;' : '';

                html += `<circle cx="${pos.x}" cy="${pos.y}" r="${nodeRadius}" fill="${fillColor}"
                         stroke="${strokeColor}" stroke-width="${strokeWidth}" style="${cursor}" ${clickHandler}/>`;
                html += `<text x="${pos.x}" y="${pos.y + 4}" text-anchor="middle" font-size="10"
                         font-weight="600" fill="white" style="pointer-events: none;">${p.name}</text>`;

                // Show preference indicator if voted against
                if (votedAgainstPref) {
                    const prefColor = p.preference === 'A' ? '#3B82F6' : '#EF4444';
                    html += `<circle cx="${pos.x + 15}" cy="${pos.y - 15}" r="7" fill="${prefColor}" stroke="white" stroke-width="1.5"/>`;
                    html += `<text x="${pos.x + 15}" y="${pos.y - 12}" text-anchor="middle" font-size="7" fill="white" font-weight="600">${p.preference}</text>`;
                }
            });

            svg.innerHTML = html;
        }

        function toggleElectionWhatIf() {
            electionData.whatIfMode = !electionData.whatIfMode;
            const panel = document.getElementById('election-whatif-panel');

            if (electionData.whatIfMode) {
                panel.style.display = 'block';
                electionData.userVotes = { ...electionData.flowResult.votes };
            } else {
                panel.style.display = 'none';
            }

            renderElectionResults();
        }

        function toggleElectionVote(personId) {
            if (!electionData.whatIfMode) return;

            electionData.userVotes[personId] = electionData.userVotes[personId] === 'A' ? 'B' : 'A';
            renderElectionResults();
        }

        function resetElectionWhatIf() {
            if (!electionData.flowResult) return;
            electionData.userVotes = { ...electionData.flowResult.votes };
            renderElectionResults();
        }

        function initElectionDemo() {
            // Load default scenario
            document.getElementById('election-scenario').value = 'dinner';
            loadElectionScenario();
            toggleElectionMode('select');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initIPLDemo();
            initFlowBuilder();
            initCertificateDemo();
            initElectionDemo();
        });

        // Also init when Reveal is ready (for slide navigation)
        Reveal.on('ready', function() {
            initIPLDemo();
            initFlowBuilder();
            initCertificateDemo();
            initElectionDemo();
        });

        Reveal.on('slidechanged', function() {
            initIPLDemo();
            initFlowBuilder();
            // Re-render election views if on those slides
            if (document.getElementById('election-social-svg')) {
                renderElectionSocialNetwork();
            }
            if (document.getElementById('election-flow-svg')) {
                renderElectionFlowNetwork();
                renderElectionSocialMini();
            }
            if (document.getElementById('election-result-svg') && electionData.flowResult) {
                renderElectionResults();
            }
        });

        // ========================================
        // SAT to Independent Set Interactive Demo
        // ========================================

        let satData = {
            clauses: [],
            variables: new Set()
        };

        function parseFormula(input) {
            // Parse format: (x,y,z)(~x,w,~z)
            // Returns array of clauses, each clause is array of literals
            const clauses = [];
            const variables = new Set();

            const clauseRegex = /\(([^)]+)\)/g;
            let match;

            while ((match = clauseRegex.exec(input)) !== null) {
                const literals = match[1].split(',').map(l => l.trim());
                const clause = literals.map(lit => {
                    const negated = lit.startsWith('~') || lit.startsWith('¬');
                    const varName = negated ? lit.substring(1) : lit;
                    variables.add(varName);
                    return { variable: varName, negated: negated };
                });
                clauses.push(clause);
            }

            return { clauses, variables: Array.from(variables).sort() };
        }

        const satExamples = [
            { formula: '(x,y,z)(~x,w,~z)(y,~w,z)', name: 'Example 1' },
            { formula: '(a,b,c)(~a,~b,d)(c,~d,a)', name: 'Example 2' },
            { formula: '(p,q,r)(~p,~q,~r)', name: 'Simple (2 clauses)' },
            { formula: '(x,y,z)(~x,~y,w)(~z,~w,x)(y,z,~w)', name: 'Larger (4 clauses)' }
        ];
        let currentExampleIdx = 0;

        function loadExampleFormula() {
            const example = satExamples[currentExampleIdx];
            document.getElementById('sat-formula-input').value = example.formula;
            currentExampleIdx = (currentExampleIdx + 1) % satExamples.length;
        }

        // Track selected vertices for independent set
        let satSelectedVertices = new Set();
        let satGraphData = null;

        function clearSATDemo() {
            satData = { clauses: [], variables: new Set() };
            satSelectedVertices = new Set();
            satGraphData = null;
            document.getElementById('sat-formula-input').value = '';
            document.getElementById('sat-to-is-svg').innerHTML = '';
            document.getElementById('sat-demo-output').innerHTML = 'Enter a 3CNF formula above and click "Build Graph" to see the reduction.';
        }

        function buildSATGraph() {
            const input = document.getElementById('sat-formula-input').value.trim();
            if (!input) {
                document.getElementById('sat-demo-output').innerHTML = '<span style="color: #c44;">Please enter a formula first.</span>';
                return;
            }

            const parsed = parseFormula(input);
            if (parsed.clauses.length === 0) {
                document.getElementById('sat-demo-output').innerHTML = '<span style="color: #c44;">Could not parse formula. Use format: (x,y,z)(~x,w,~z)</span>';
                return;
            }

            satData = parsed;
            satSelectedVertices = new Set();
            renderSATGraph();
        }

        function toggleSATVertex(nodeId) {
            if (satSelectedVertices.has(nodeId)) {
                satSelectedVertices.delete(nodeId);
            } else {
                satSelectedVertices.add(nodeId);
            }
            renderSATGraph();
        }

        function validateSATSelection() {
            if (!satGraphData) {
                document.getElementById('sat-demo-output').innerHTML = '<span style="color: #c44;">Please build a graph first.</span>';
                return;
            }

            const selected = Array.from(satSelectedVertices);
            const targetSize = satGraphData.n + satGraphData.k;

            // Check if it's an independent set (no two selected vertices are adjacent)
            let isIndependent = true;
            let conflictEdge = null;

            for (let i = 0; i < selected.length && isIndependent; i++) {
                for (let j = i + 1; j < selected.length && isIndependent; j++) {
                    const v1 = selected[i];
                    const v2 = selected[j];
                    // Check if edge exists
                    if (satGraphData.edges.some(e => (e.from === v1 && e.to === v2) || (e.from === v2 && e.to === v1))) {
                        isIndependent = false;
                        conflictEdge = [v1, v2];
                    }
                }
            }

            const outputEl = document.getElementById('sat-demo-output');
            if (selected.length === 0) {
                outputEl.innerHTML = '<span style="color: #666;">Click on vertices to select them, then click "Validate IS" to check.</span>';
            } else if (!isIndependent) {
                outputEl.innerHTML = `<span style="color: #c44;"><strong>Not an independent set!</strong> Vertices <strong>${conflictEdge[0]}</strong> and <strong>${conflictEdge[1]}</strong> are adjacent.</span>`;
            } else if (selected.length < targetSize) {
                outputEl.innerHTML = `<span style="color: #e67700;"><strong>Valid independent set of size ${selected.length}</strong>, but target is <strong>${targetSize}</strong>. Need ${targetSize - selected.length} more vertices.</span>`;
            } else if (selected.length === targetSize) {
                outputEl.innerHTML = `<span style="color: #059669;"><strong>Correct!</strong> You found an independent set of size <strong>${targetSize}</strong> = ${satGraphData.n} (variables) + ${satGraphData.k} (clauses). The formula is satisfiable!</span>`;
            } else {
                outputEl.innerHTML = `<span style="color: #059669;"><strong>Valid independent set of size ${selected.length}!</strong> (Target was ${targetSize})</span>`;
            }
        }

        function renderSATGraph() {
            const svg = document.getElementById('sat-to-is-svg');
            if (!svg) return;

            const clauses = satData.clauses;
            const variables = satData.variables;
            const k = clauses.length;
            const n = variables.length;
            const targetBudget = n + k;

            // Calculate dimensions
            const svgWidth = Math.max(650, Math.min(950, 160 * Math.max(k, n)));
            const svgHeight = 360;
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);

            // Position calculations
            const varGadgetY = 55;
            const varSpacing = (svgWidth - 140) / (n + 1);
            const clauseY = 265;
            const clauseSpacing = svgWidth / (k + 1);
            const triangleRadius = 42;

            // Store node positions and edges for validation
            const nodePositions = {};
            const varGadgetPositions = {};
            const edges = [];

            let html = '';

            // Draw variable gadgets (matching) at the top
            variables.forEach((varName, vi) => {
                const vx = (vi + 1) * varSpacing;
                const posY = varGadgetY - 18;
                const negY = varGadgetY + 18;

                const posNodeId = `var_${varName}`;
                const negNodeId = `var_~${varName}`;

                // Store positions
                varGadgetPositions[varName] = { x: vx, y: posY, nodeId: posNodeId };
                varGadgetPositions['~' + varName] = { x: vx, y: negY, nodeId: negNodeId };
                nodePositions[posNodeId] = { x: vx, y: posY, type: 'var', varName, negated: false };
                nodePositions[negNodeId] = { x: vx, y: negY, type: 'var', varName, negated: true };

                // Matching edge
                edges.push({ from: posNodeId, to: negNodeId, type: 'matching' });
                html += `<line x1="${vx}" y1="${posY + 12}" x2="${vx}" y2="${negY - 12}" stroke="#059669" stroke-width="2"/>`;

                // Draw positive vertex (clickable)
                const posSelected = satSelectedVertices.has(posNodeId);
                html += `
                    <circle cx="${vx}" cy="${posY}" r="12" fill="${posSelected ? '#fbbf24' : '#a8d4f0'}" stroke="${posSelected ? '#d97706' : '#222'}" stroke-width="${posSelected ? 3 : 1.5}" style="cursor: pointer;" onclick="toggleSATVertex('${posNodeId}')"/>
                    <text x="${vx}" y="${posY + 4}" text-anchor="middle" font-family="EB Garamond" font-size="11" fill="#222" style="pointer-events: none;">${varName}</text>
                `;

                // Draw negative vertex (clickable)
                const negSelected = satSelectedVertices.has(negNodeId);
                html += `
                    <circle cx="${vx}" cy="${negY}" r="12" fill="${negSelected ? '#fbbf24' : '#f5c4c0'}" stroke="${negSelected ? '#d97706' : '#222'}" stroke-width="${negSelected ? 3 : 1.5}" style="cursor: pointer;" onclick="toggleSATVertex('${negNodeId}')"/>
                    <text x="${vx}" y="${negY + 4}" text-anchor="middle" font-family="EB Garamond" font-size="11" fill="#222" style="pointer-events: none;">${varName}̄</text>
                `;
            });

            // Label for variable gadgets
            html += `<text x="${(svgWidth - 140) / 2}" y="12" text-anchor="middle" font-family="Heliotrope" font-size="10" fill="#666">Variable Gadgets</text>`;

            // Draw clause triangles
            clauses.forEach((clause, ci) => {
                const cx = (ci + 1) * clauseSpacing;
                const cy = clauseY;

                const positions = [
                    { x: cx, y: cy - triangleRadius },
                    { x: cx - triangleRadius * 0.866, y: cy + triangleRadius * 0.5 },
                    { x: cx + triangleRadius * 0.866, y: cy + triangleRadius * 0.5 }
                ];

                // Draw triangle edges
                for (let i = 0; i < 3 && i < clause.length; i++) {
                    const j = (i + 1) % Math.min(clause.length, 3);
                    html += `<line x1="${positions[i].x}" y1="${positions[i].y}" x2="${positions[j].x}" y2="${positions[j].y}" stroke="#222" stroke-width="1.5"/>`;
                }

                // Store triangle edges
                for (let i = 0; i < clause.length && i < 3; i++) {
                    for (let j = i + 1; j < clause.length && j < 3; j++) {
                        const id1 = `c${ci}_${clause[i].negated ? '~' : ''}${clause[i].variable}`;
                        const id2 = `c${ci}_${clause[j].negated ? '~' : ''}${clause[j].variable}`;
                        edges.push({ from: id1, to: id2, type: 'clause' });
                    }
                }

                // Draw vertices
                clause.forEach((lit, li) => {
                    if (li >= 3) return;
                    const pos = positions[li];
                    const nodeId = `c${ci}_${lit.negated ? '~' : ''}${lit.variable}`;
                    nodePositions[nodeId] = { ...pos, lit, type: 'clause', clauseIdx: ci };

                    const label = lit.negated ? `${lit.variable}̄` : lit.variable;
                    const baseFill = lit.negated ? '#f5c4c0' : '#a8d4f0';
                    const isSelected = satSelectedVertices.has(nodeId);

                    html += `
                        <circle cx="${pos.x}" cy="${pos.y}" r="14" fill="${isSelected ? '#fbbf24' : baseFill}" stroke="${isSelected ? '#d97706' : '#222'}" stroke-width="${isSelected ? 3 : 1.5}" style="cursor: pointer;" onclick="toggleSATVertex('${nodeId}')"/>
                        <text x="${pos.x}" y="${pos.y + 4}" text-anchor="middle" font-family="EB Garamond" font-size="11" fill="#222" style="pointer-events: none;">${label}</text>
                    `;

                    // Consistency edge to variable gadget
                    const targetKey = lit.negated ? lit.variable : '~' + lit.variable;
                    const targetData = varGadgetPositions[targetKey];
                    if (targetData) {
                        edges.push({ from: nodeId, to: targetData.nodeId, type: 'consistency' });
                        html += `<line x1="${pos.x}" y1="${pos.y - 14}" x2="${targetData.x}" y2="${targetData.y + 12}" stroke="#c44" stroke-width="1.5" stroke-dasharray="4,2" opacity="0.4"/>`;
                    }
                });

                // Clause label
                const clauseStr = '(' + clause.slice(0, 3).map(l => l.negated ? `${l.variable}̄` : l.variable).join(' ∨ ') + ')';
                html += `<text x="${cx}" y="${cy + triangleRadius + 22}" text-anchor="middle" font-family="Heliotrope" font-size="9" fill="#666">${clauseStr}</text>`;
            });

            // Legend (four lines, top right)
            const legendX = svgWidth - 130;
            html += `
                <rect x="${legendX}" y="5" width="125" height="80" fill="white" stroke="#ccc" rx="3"/>
                <circle cx="${legendX + 12}" cy="20" r="6" fill="#a8d4f0" stroke="#222"/>
                <text x="${legendX + 22}" y="23" font-size="9" fill="#333">Positive literal</text>
                <circle cx="${legendX + 12}" cy="36" r="6" fill="#f5c4c0" stroke="#222"/>
                <text x="${legendX + 22}" y="39" font-size="9" fill="#333">Negated literal</text>
                <line x1="${legendX + 6}" y1="52" x2="${legendX + 18}" y2="52" stroke="#059669" stroke-width="2"/>
                <text x="${legendX + 22}" y="55" font-size="9" fill="#333">Matching edge</text>
                <line x1="${legendX + 6}" y1="68" x2="${legendX + 18}" y2="68" stroke="#c44" stroke-width="1.5" stroke-dasharray="4,2"/>
                <text x="${legendX + 22}" y="71" font-size="9" fill="#333">Consistency edge</text>
            `;

            svg.innerHTML = html;

            // Store graph data for validation
            satGraphData = { n, k, edges, nodePositions };

            // Update output
            const totalVertices = (2 * n) + clauses.reduce((sum, c) => sum + Math.min(c.length, 3), 0);
            const selectedCount = satSelectedVertices.size;
            document.getElementById('sat-demo-output').innerHTML = `
                <strong>Reduction complete!</strong>
                Formula: <strong>${k} clauses</strong>, <strong>${n} variables</strong>.
                Graph: <strong>${totalVertices} vertices</strong>.
                <span style="color: #059669; font-weight: 600;">Target IS size = ${targetBudget}</span> (${n} vars + ${k} clauses).
                ${selectedCount > 0 ? `<br><span style="color: #d97706;">Selected: <strong>${selectedCount}</strong> vertices. Click "Validate IS" to check.</span>` : ''}
            `;
        }
    </script>
</body>
</html>
